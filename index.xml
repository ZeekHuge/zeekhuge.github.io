<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>ZeekHuge (Zubeen Tolani)</title>
    <link>https://www.zeekhuge.me/</link>
    <description>Recent content on ZeekHuge (Zubeen Tolani)</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 17 Jul 2016 23:37:27 +0530</lastBuildDate>
    <atom:link href="https://www.zeekhuge.me/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>PTP - Programming The PRUs 2: Docs, Commands and Tools</title>
      <link>https://www.zeekhuge.me/post/ptp_docs_commands_and_tools/</link>
      <pubDate>Sun, 17 Jul 2016 23:37:27 +0530</pubDate>
      
      <guid>https://www.zeekhuge.me/post/ptp_docs_commands_and_tools/</guid>
      <description>

&lt;p&gt;&lt;img src=&#34;https://www.zeekhuge.me/jokes/tools.png&#34; alt=&#34;Tools&#34; /&gt;&lt;/p&gt;

&lt;p&gt;picture credits : &lt;a href=&#34;https://xkcd.com&#34;&gt;xkcd.com&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;u-preface-u:de018d5265887708b1682007c1f4431a&#34;&gt;&lt;u&gt;Preface:&lt;/u&gt;&lt;/h3&gt;

&lt;p&gt;If the content here seems to be out of context, you&amp;rsquo;ll probably want to start from &lt;a href=&#34;https://www.zeekhuge.me/post/ptp_blinky&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;So you have decided to play with PRUs and after this &lt;a href=&#34;https://www.zeekhuge.me/post/ptp_blinky&#34;&gt;blinky&lt;/a&gt; post, you have some understanding about how to work with PRUs. Cool ! Thats a courageous decision, as PRUs are quite challenging. To make life easier, we need some tools to work along. This post will help you make some of your own tools, using mostly bash scripts/aliases, and explain how to use other known tools with PRUs. Please note that some of the tools/use-cases will not make sense as of now, but I will still include them in the post for future reference. Some of these tools might seem very trivial, but I would still like to mention them (it may give hope to someone :) )&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;u-contents-u:de018d5265887708b1682007c1f4431a&#34;&gt;&lt;u&gt;Contents&lt;/u&gt;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#docs:de018d5265887708b1682007c1f4431a&#34;&gt;Documents&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;AM335x PRU-ICSS Reference Guide&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#cmd:de018d5265887708b1682007c1f4431a&#34;&gt;Commands&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#pmd:de018d5265887708b1682007c1f4431a&#34;&gt;Power management : PRUs : Details&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#pmc:de018d5265887708b1682007c1f4431a&#34;&gt;Power management : PRUs : Commands&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;To shut PRU core 1&lt;/li&gt;
&lt;li&gt;To shut PRU core 0&lt;/li&gt;
&lt;li&gt;To boot PRU core 1&lt;/li&gt;
&lt;li&gt;To boot PRU core 0&lt;/li&gt;
&lt;li&gt;To reboot both PRU cores&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#pdd:de018d5265887708b1682007c1f4431a&#34;&gt;PRU debug : Details&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#pdc:de018d5265887708b1682007c1f4431a&#34;&gt;PRU debug : Commands&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;ppause1 and ppause0 - to pause the PRUs&lt;/li&gt;
&lt;li&gt;presume1 and presume0 - to resume the PRUs&lt;/li&gt;
&lt;li&gt;pnext1 and pnext0 - to execute the next step&lt;/li&gt;
&lt;li&gt;pregs1 and pregs0 - to read the debug register content of the PRUs&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#tools:de018d5265887708b1682007c1f4431a&#34;&gt;Tools&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#dmesg:de018d5265887708b1682007c1f4431a&#34;&gt;dmesg : kernel logs and the PRU&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#fin:de018d5265887708b1682007c1f4431a&#34;&gt;fin&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;docs:de018d5265887708b1682007c1f4431a&#34;&gt;&lt;u&gt;Documents&lt;/u&gt;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;You definitely know that the AM335x processor is manufactured by TI, and only they know what actually is inside the semiconductor. To tell this to the world, every semiconductor device, open to the world, comes with some kind of document explaining its internal working. For PRUs, I found the document at &lt;a href=&#34;https://github.com/beagleboard/am335x_pru_package/&#34;&gt;https://github.com/beagleboard/am335x_pru_package/&lt;/a&gt;. The pdf named am335xPruReferenceGuide.pdf is the one I am talking about. Its an ultimately important and nice document to keep with you. I use it all the time, when I am working with PRUs. If you want to download this click &lt;a href=&#34;https://github.com/beagleboard/am335x_pru_package/raw/master/am335xPruReferenceGuide.pdf&#34;&gt;here&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;cmd:de018d5265887708b1682007c1f4431a&#34;&gt;&lt;u&gt;Commands&lt;/u&gt;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;In this section, we will add some commands to use them as our tools. &lt;strong&gt;Please note that these commands may not be very clean, but they definitely server the purpose. When you will execute them, they might produce some output, but dont worry much about it, we can use &amp;lsquo;dmesg&amp;rsquo; to do the real debugging and monitor what is happening as I have explained below in the post&lt;/strong&gt;. There will be an explanation about the working of the commands also.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h5 id=&#34;pmd:de018d5265887708b1682007c1f4431a&#34;&gt;&lt;u&gt;Power management : PRUs : Details&lt;/u&gt;&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;This &lt;a href=&#34;https://www.zeekhuge.me/post/ptp_blinky/&#34;&gt;blinky post&lt;/a&gt; demonstrated how the deploy.sh script reboots the PRU. Now if you are deciding to play with PRUs frequently, there needs to be a tool to shut them down and boot them up, when needed, without doing the force rmmod of the pru_rproc. Now the remoteproc driver for PRUs, pru_proc handles the PRU core. It further exposes sysfs entries to boot and shutdown PRUs. So for PRU0 you can shut it down like this :
&lt;pre class=&#34;prettyprint&#34;&gt;
$ echo &amp;ldquo;4a334000.pru0&amp;rdquo; &amp;gt; /sys/bus/platform/drivers/pru-rproc/unbind
&lt;/pre&gt;
and boot it up :
&lt;pre class=&#34;prettyprint&#34;&gt;
$ echo &amp;ldquo;4a334000.pru0&amp;rdquo; &amp;gt; /sys/bus/platform/drivers/pru-rproc/bind
&lt;/pre&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;At this point, you would want to make this &lt;strong&gt;note that the device name of PRU core 0 is actually &lt;u&gt;4a334000.pru0&lt;/u&gt; and that of the PRU core 1 is &lt;u&gt;4a338000.pru1&lt;/u&gt;.&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;So writing the device name of any of the pru cores to the &amp;lsquo;bind&amp;rsquo; sysfs entry will make the remoteproc driver to boot that pru core. Similarly, writing a pru device name to &amp;lsquo;unbind&amp;rsquo; sysfs entry will make that pru core to shutdown.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;pmc:de018d5265887708b1682007c1f4431a&#34;&gt;&lt;u&gt;Power management : PRUs : Commands&lt;/u&gt;&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;While working, I really don&amp;rsquo;t like to type this long instruction to shutdown or boot the PRU. What I do is, I have added some aliases to my ~/.bashrc script, and believe me, they really make things easy. Just open the ~/.bash.rc in your favorite editor and append it with following aliases.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;pshut1 : To shut PRU core 1&lt;/strong&gt;
&lt;pre class=&#34;prettyprint&#34;&gt;
alias pshut1=&amp;lsquo;echo 4a338000.pru1&amp;gt;/sys/bus/platform/drivers/pru-rproc/unbind &amp;amp;&amp;amp; echo “Core 1 is off”&amp;rsquo;
&lt;/pre&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;pshut0 : To shut PRU core 0&lt;/strong&gt;
&lt;pre class=&#34;prettyprint&#34;&gt;
alias pshut0=&amp;lsquo;echo 4a334000.pru0&amp;gt;/sys/bus/platform/drivers/pru-rproc/unbind &amp;amp;&amp;amp; echo “Core 0 is off”&amp;rsquo;
&lt;/pre&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;pboot1 : To boot PRU core 1&lt;/strong&gt;
&lt;pre class=&#34;prettyprint&#34;&gt;
alias pboot1=&amp;lsquo;echo 4a338000.pru1&amp;gt;/sys/bus/platform/drivers/pru-rproc/bind &amp;amp;&amp;amp; echo “Core 1 is on”&amp;rsquo;
&lt;/pre&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;pboot0 : To boot PRU core 0&lt;/strong&gt;
&lt;pre class=&#34;prettyprint&#34;&gt;
alias pboot0=&amp;lsquo;echo 4a334000.pru0&amp;gt;/sys/bus/platform/drivers/pru-rproc/bind &amp;amp;&amp;amp; echo “Core 0 is on”&amp;rsquo;
&lt;/pre&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;preboot : To reboot both PRU cores&lt;/strong&gt;
&lt;pre class=&#34;prettyprint&#34;&gt;
alias preboot=&amp;lsquo;echo 4a338000.pru1&amp;gt;/sys/bus/platform/drivers/pru-rproc/unbind &amp;amp;&amp;amp;
           echo 4a334000.pru0&amp;gt;/sys/bus/platform/drivers/pru-rproc/unbind &amp;amp;&amp;amp;
           echo 4a338000.pru1&amp;gt;/sys/bus/platform/drivers/pru-rproc/bind &amp;amp;&amp;amp;
           echo 4a334000.pru0&amp;gt;/sys/bus/platform/drivers/pru-rproc/bind &amp;amp;&amp;amp;
           echo &amp;ldquo;PRUs rebooted&amp;rdquo;&amp;rsquo;
&lt;/pre&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;pdd:de018d5265887708b1682007c1f4431a&#34;&gt;&lt;u&gt;PRU debug : Details&lt;/u&gt;&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Now here comes the interesting section. The PRUs are usually seen as these &amp;lsquo;black boxes&amp;rsquo; as no one knows what is happening inside it. With the latest remoteproc, this is not true. We can actually see the content of the PRU registers or we can pru execute one instruction at a time, and then wait for the user for a instruction to execute next instruction. The pru_rproc driver exposes these debugfs entries :
&lt;pre class=&#34;prettyprint&#34;&gt;
$ root@beaglebone:/sys/kernel/debug/remoteproc# tree remoteproc0
remoteproc0
|&amp;ndash; name
|&amp;ndash; recovery
|&amp;ndash; state
|&amp;ndash; trace0
&lt;code&gt;-- version
&lt;/code&gt;
0 directories, 5 files
root@beaglebone:/sys/kernel/debug/remoteproc# tree remoteproc1
remoteproc1
|&amp;ndash; name
|&amp;ndash; recovery
|&amp;ndash; regs
|&amp;ndash; single_step
|&amp;ndash; state
&lt;code&gt;-- version
&lt;/code&gt;
0 directories, 6 files
&lt;/pre&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;NOTE that all these entries will appear only when the associated PRU is properly booted.&lt;/strong&gt; So remoteproc1 is associated with PRU1 and remoteproc0 is associated with PRU0.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;PRUs have this nice feature called the SINGLE_STEP mode. When activated in this mode, the PRU core executes one instruction, waits for a kind of flag from the user, executes the next instruction and this continues. To get PRU0 in the SINGLE_STEP mode, just :
&lt;pre class=&#34;prettyprint&#34;&gt;
$ echo 1 &amp;gt; /sys/kernel/debug/remoteproc/remoteproc0/single_step
&lt;/pre&gt;
and for PRU1 it will be
&lt;pre class=&#34;prettyprint&#34;&gt;
$ echo 1 &amp;gt; /sys/kernel/debug/remoteproc/remoteproc1/single_step
&lt;/pre&gt;
So basically, writing 0 to the single_step entry, changes the PRU mode to continuous mode and writing a non-zero value starts the single_step mode. Internally, writing to single_step entry writes to the SINGLE_STEP field of the CONTROL register in the PRU_CTRL register set.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Like any other computing system, PRUs has got a set of register and data-structures, for various purposes. Some of these are:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;General Purpose registers.&lt;/strong&gt; So each PRU core has got this set of 32 general purpose register. While programming PRUs in C/C++, the compiler makes use of these registers for various purposes and one cant actually access a single register in C/C++, exception being the R31 and R30 register. But when programming them in Assembly, having something to peek into the contents of these register can be very useful tool. When the PRU is disabled, that is, it is not in continuous mode of fetching next instruction, the Kernel can actually read the content of these general purpose register.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;PRU_CONTROL register.&lt;/strong&gt; PRUs has this set of registers called PRU_CTRL (read it PRU control) registers. It consists of CONTROL, STATUS, WAKEUP_EN, CYCLE, STALL, CTBIR0, CTBIR1, CTPPR0 and CTPPR1 register. The control various subsystems and accesses. The kernel can, at anytime read the content of these registers. By &amp;lsquo;anytime&amp;rsquo; I mean that the PRU does not need to be disabled to read this register set.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;PRU constant table.&lt;/strong&gt; This data structure contains the address of various subsystem that are most commonly used by the PRUs. Some of its entries can also be configured using the PRU_CTR registers. Programming in C/C++ removes the need of any access to this structure, it internally manages everything (except in a few cases). But if needed, the kernel can read the content of the constant table too, provided, the pru is disabled.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;To disable the PRUs, what one can do from userspace is, just write a non-zero value to the single_step debugfs entry, the PRU will execute one instruction and then will disable itself until you again write a value to the entry. In fact this is how the single_step mode works.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;After disabling the PRU, you can use the &amp;lsquo;regs&amp;rsquo; entry to read the register content values.
&lt;pre class=&#34;prettyprint&#34;&gt;
$ cat /sys/kernel/debug/remoteproc/remoteproc1/regs
============== Control Registers ==============
CTRL      := 0x00000101
STS (PC)  := 0x00000028 (0x000000a0)
WAKEUP_EN := 0x00000000
CYCLE     := 0x00000000
STALL     := 0x00000000
CTBIR0    := 0x00000000
CTBIR1    := 0x00000000
CTPPR0    := 0x00000000
CTPPR1    := 0x00000000
=============== Debug Registers ===============
GPREG0  := 0x7fff8000   CT_REG0  := 0x00020000
GPREG1  := 0x9e103100   CT_REG1  := 0x48040000
GPREG2  := 0x000002ac   CT_REG2  := 0x4802a000
GPREG3  := 0x0035003b   CT_REG3  := 0x00030000
GPREG4  := 0x00020024   CT_REG4  := 0x00026000
GPREG5  := 0x00000300   CT_REG5  := 0x48060000
GPREG6  := 0xdfd3df83   CT_REG6  := 0x48030000
GPREG7  := 0xf9c1a30b   CT_REG7  := 0x00028000
GPREG8  := 0x215e3af4   CT_REG8  := 0x46000000
GPREG9  := 0x2868c478   CT_REG9  := 0x4a100000
GPREG10 := 0x26e01c54   CT_REG10 := 0x48318000
GPREG11 := 0xaf704e74   CT_REG11 := 0x48022000
GPREG12 := 0x51588e6f   CT_REG12 := 0x48024000
GPREG13 := 0x667bc7c2   CT_REG13 := 0x48310000
GPREG14 := 0x0000ffff   CT_REG14 := 0x481cc000
GPREG15 := 0x00000290   CT_REG15 := 0x481d0000
GPREG16 := 0x0000028c   CT_REG16 := 0x481a0000
GPREG17 := 0x00000000   CT_REG17 := 0x4819c000
GPREG18 := 0x000002ac   CT_REG18 := 0x48300000
GPREG19 := 0x000a6465   CT_REG19 := 0x48302000
GPREG20 := 0x02100000   CT_REG20 := 0x48304000
GPREG21 := 0x01120011   CT_REG21 := 0x00032400
GPREG22 := 0x0000001e   CT_REG22 := 0x480c8000
GPREG23 := 0x00000000   CT_REG23 := 0x480ca000
GPREG24 := 0x75727265   CT_REG24 := 0x00000000
GPREG25 := 0x64657470   CT_REG25 := 0x00002000
GPREG26 := 0x6e616843   CT_REG26 := 0x0002e000
GPREG27 := 0x206c656e   CT_REG27 := 0x00032000
GPREG28 := 0x49003033   CT_REG28 := 0x00000000
GPREG29 := 0x7265746e   CT_REG29 := 0x49000000
GPREG30 := 0xe5e2782f   CT_REG30 := 0x40000000
GPREG31 := 0x80000000   CT_REG31 := 0x80000000
&lt;/pre&gt;
In the above output&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;GPREGn refers to the nth general prupose register&lt;/li&gt;
&lt;li&gt;CT_REGn refers to the nth content of the constant table.&lt;/li&gt;
&lt;li&gt;And the &amp;lsquo;Control Registers&amp;rsquo; section displays the content of the PRU_CTRL registers.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;pdc:de018d5265887708b1682007c1f4431a&#34;&gt;&lt;u&gt;PRU debug : Commands&lt;/u&gt;&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;So here comes the set of aliases that I use to control PRUs for debugging. Just append them to your ~/.bashrc file and the will be in effect you login next time.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;ppause1 and ppause0 - to pause the PRUs.&lt;/strong&gt; This basically changes the mode of the PRUs to single_step mode. PRUs execute one instruction and then gets paused
&lt;pre class=&#34;prettyprint&#34;&gt;
alias ppause1=&amp;lsquo;echo 1 &amp;gt; /sys/kernel/debug/remoteproc/remoteproc1/single_step&amp;rsquo;
alias ppause0=&amp;lsquo;echo 1 &amp;gt; /sys/kernel/debug/remoteproc/remoteproc0/single_step&amp;rsquo;
&lt;/pre&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;presume1 and presume0 - to resume the PRUs.&lt;/strong&gt; Internally this brings back the PRU to continuous mode of operation.
&lt;pre class=&#34;prettyprint&#34;&gt;
alias presume1=&amp;lsquo;echo 0 &amp;gt; /sys/kernel/debug/remoteproc/remoteproc1/single_step&amp;rsquo;
alias presume0=&amp;lsquo;echo 0 &amp;gt; /sys/kernel/debug/remoteproc/remoteproc0/single_step&amp;rsquo;
&lt;/pre&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;pnext1 and pnext0 - to execute the next step.&lt;/strong&gt; This starts the single_step mode of the PRUs and execute one next step each time invoked.
&lt;pre class=&#34;prettyprint&#34;&gt;
alias pnext1=&amp;lsquo;echo 1 &amp;gt; /sys/kernel/debug/remoteproc/remoteproc1/single_step&amp;rsquo;
alias pnext0=&amp;lsquo;echo 1 &amp;gt; /sys/kernel/debug/remoteproc/remoteproc0/single_step&amp;rsquo;
&lt;/pre&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;pregs1 and pregs0 - to read the debug register content of the PRUs.&lt;/strong&gt; If you want to read all the register content, the PRU need to paused before the call to this alias. If it is not paused, only the PRU_CONTROL register content will be printed out.
&lt;pre class=&#34;prettyprint&#34;&gt;
alias pregs1=&amp;lsquo;cat /sys/kernel/debug/remoteproc/remoteproc1/regs&amp;rsquo;
alias pregs0=&amp;lsquo;cat /sys/kernel/debug/remoteproc/remoteproc0/regs&amp;rsquo;
&lt;/pre&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;tools:de018d5265887708b1682007c1f4431a&#34;&gt;&lt;u&gt;Tools&lt;/u&gt;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Well, after all these commands/aliases we just added in the above section, I have one tool left for you that is &amp;lsquo;dmesg&amp;rsquo;.&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;dmesg:de018d5265887708b1682007c1f4431a&#34;&gt;&lt;u&gt;dmesg : kernel logs and the PRU&lt;/u&gt;&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Yeah, I know that you already know this, but believe me, this &amp;lsquo;dmesg&amp;rsquo; point this blog can prove to save many hours(and probably lives). OK so you think I am just wasting up space mentioning this point here ? really ? well, then just let me use some more of it :P&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Whenever I start working with the PRUs, what I usually do is, open up a new terminal, ssh into the BBB, change the title of the terminal to &amp;lsquo;BBB dmesg&amp;rsquo; to make it easy to switch between 10-12 terminals, and then execute this command :
&lt;pre class=&#34;prettyprint&#34;&gt;
$ dmesg -Hw
&lt;/pre&gt;
What it does is that it waits for new kernel log messages and prints them as they arrive. It also makes the output a bit colorful.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;On booting or shutting down the PRUs, the remoteproc drivers print some kernel logs. These kernel log messages can be used to check if the firmware gets loaded on the PRU.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Kernel log messages when the PRUs are booted up :
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
[  +5.822834]  remoteproc1: 4a334000.pru0 is available
[  +0.005249]  remoteproc1: Note: remoteproc is still under development and considered experimental.
[  +0.009165]  remoteproc1: THE BINARY FORMAT IS NOT YET FINALIZED, and backward compatibility isn&amp;rsquo;t yet guaranteed.
[  +0.019388] pru-rproc 4a334000.pru0: booting the PRU core manually
[  +0.006738]  remoteproc1: powering up 4a334000.pru0
[  +0.011898]  remoteproc1: Booting fw image am335x-pru0-fw, size 32292
[  +0.006832]  remoteproc1: remote processor 4a334000.pru0 is now up
[  +0.006434] pru-rproc 4a334000.pru0: PRU rproc node /ocp/pruss@4a300000/pru0@4a334000 probed successfully
[  +0.022337]  remoteproc2: 4a338000.pru1 is available
[  +0.005196]  remoteproc2: Note: remoteproc is still under development and considered experimental.
[  +0.009167]  remoteproc2: THE BINARY FORMAT IS NOT YET FINALIZED, and backward compatibility isn&amp;rsquo;t yet guaranteed.
[  +0.017694] pru-rproc 4a338000.pru1: booting the PRU core manually
[  +0.006884]  remoteproc2: powering up 4a338000.pru1
[  +0.011585]  remoteproc2: Booting fw image am335x-pru1-fw, size 32292
[  +0.006809]  remoteproc2: remote processor 4a338000.pru1 is now up
[  +0.006440] pru-rproc 4a338000.pru1: PRU rproc node /ocp/pruss@4a300000/pru1@4a338000 probed successfully
&lt;/pre&gt;
This message can be a bit different for complex and different firmwares, but the important point to note here is the loading of the firmware onto the PRUs. The line in the dmesg that shows this is:
&lt;pre class=&#34;prettyprint &#34;&gt;
[  +0.006832]  remoteproc1: remote processor 4a334000.pru0 is now up
[  +0.006434] pru-rproc 4a334000.pru0: PRU rproc node /ocp/pruss@4a300000/pru0@4a334000 probed successfully
&lt;/pre&gt;
and
&lt;pre class=&#34;prettyprint &#34;&gt;
[  +0.006884]  remoteproc2: powering up 4a338000.pru1
[  +0.011585]  remoteproc2: Booting fw image am335x-pru1-fw, size 32292
&lt;/pre&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Kernel log message when the PRUs get shutdown :
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
[Jul17 15:40] pru-rproc 4a334000.pru0: pru_rproc_remove: removing rproc 4a334000.pru0
[  +0.007909] pru-rproc 4a334000.pru0: stopping the manually booted PRU core
[  +0.017800] ti-pruss 4a300000.pruss: unconfigured system_events = 0xffffffffffffffff host_intr = 0x00000001
[  +0.010081]  remoteproc1: stopped remote processor 4a334000.pru0
[  +0.012963]  remoteproc1: releasing 4a334000.pru0
[  +0.010409] pru-rproc 4a338000.pru1: pru_rproc_remove: removing rproc 4a338000.pru1
[  +0.007950] pru-rproc 4a338000.pru1: stopping the manually booted PRU core
[  +0.015339] ti-pruss 4a300000.pruss: unconfigured system_events = 0xffffffffffffffff host_intr = 0x00000001
[  +0.010043]  remoteproc2: stopped remote processor 4a338000.pru1
[  +0.012716]  remoteproc2: releasing 4a338000.pru1
&lt;/pre&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Kernel log messages when the firmware could not be loaded onto the PRUs :
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
[Jul17 15:45]  remoteproc1: 4a334000.pru0 is available
[  +0.005235]  remoteproc1: Note: remoteproc is still under development and considered experimental.
[  +0.009203]  remoteproc1: THE BINARY FORMAT IS NOT YET FINALIZED, and backward compatibility isn&amp;rsquo;t yet guaranteed.
[  +0.019418]  remoteproc1: Direct firmware load for am335x-pru0-fw failed with error -2
[  +0.008195]  remoteproc1: failed to load am335x-pru0-fw
[  +0.010259] pru-rproc 4a334000.pru0: booting the PRU core manually
[  +0.006529]  remoteproc1: powering up 4a334000.pru0
[  +0.013469]  remoteproc1: Direct firmware load for am335x-pru0-fw failed with error -2
[  +0.008150]  remoteproc1: request_firmware failed: -2
[  +0.005235] pru-rproc 4a334000.pru0: rproc_boot failed
[  +0.012949]  remoteproc1: releasing 4a334000.pru0
[  +0.005070] pru-rproc: probe of 4a334000.pru0 failed with error -2
[  +0.012818]  remoteproc1: 4a338000.pru1 is available
[  +0.005158]  remoteproc1: Note: remoteproc is still under development and considered experimental.
[  +0.009091]  remoteproc1: THE BINARY FORMAT IS NOT YET FINALIZED, and backward compatibility isn&amp;rsquo;t yet guaranteed.
[  +0.014271]  remoteproc1: Direct firmware load for am335x-pru1-fw failed with error -2
[  +0.008084]  remoteproc1: failed to load am335x-pru1-fw
[  +0.007755] pru-rproc 4a338000.pru1: booting the PRU core manually
[  +0.009969]  remoteproc1: powering up 4a338000.pru1
[  +0.005178]  remoteproc1: Direct firmware load for am335x-pru1-fw failed with error -2
[  +0.008057]  remoteproc1: request_firmware failed: -2
[  +0.005121] pru-rproc 4a338000.pru1: rproc_boot failed
[  +0.009849]  remoteproc1: releasing 4a338000.pru1
[  +0.005094] pru-rproc: probe of 4a338000.pru1 failed with error -2
&lt;/pre&gt;
This is mostly when there is no file like am335x-pru1-fw or am335x-pru0-fw available inside the /lib/firmware/ directory.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;fin:de018d5265887708b1682007c1f4431a&#34;&gt;&lt;u&gt;fin&lt;/u&gt;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;So, with these tools, I hope that that your learning speed gets faster and the process gets much easier. I would close this post with these lines of Abraham Lincoln&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;&amp;ldquo;Give me Six hours to chop down a tree and I will spend
first four sharpening the axe&amp;rdquo;&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>PTP - Programming The PRUs 1: Blinky</title>
      <link>https://www.zeekhuge.me/post/ptp_blinky/</link>
      <pubDate>Sat, 16 Jul 2016 15:45:08 +0530</pubDate>
      
      <guid>https://www.zeekhuge.me/post/ptp_blinky/</guid>
      <description>

&lt;p&gt;&lt;strong&gt;This is the first post in a series of posts that will try to put the PRU programming process in the simplest and the most logical form, connecting all the dots (rpmsg, remoteproc etc). The posts of this series will have PTP (Programming The Pru) at the beginning of its title. As its just the beginning, this post aims to get you a blinky application using PRUs on your BeagleBone Black.&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;u-preface-u:a6dc26714d32df1ac6a7aa69d40ae020&#34;&gt;&lt;u&gt;Preface&lt;/u&gt;&lt;/h3&gt;

&lt;p&gt;Some people might say, &lt;em&gt;&amp;ldquo;Really ? A blinky ? Are you kidding me ? If someone is trying to get started with PRUs, he/she&amp;rsquo;s most probably knows the concepts of embedded programming well.&amp;rdquo;&lt;/em&gt; And to them, I would just say &lt;em&gt;&amp;ldquo;yes, a blinky.&amp;rdquo;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;However experienced an embedded programmer is, blinky can still be the most thrilling application that he develops. It is thrilling at least to me, and I just put my hands up in the air like I have won a war. Further, this post will help you get all the things at the right place to begin with more complex examples. If you still don&amp;rsquo;t think its worth it, well, Its my post :P&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;u-content-u:a6dc26714d32df1ac6a7aa69d40ae020&#34;&gt;&lt;u&gt;Content&lt;/u&gt;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#ptr:a6dc26714d32df1ac6a7aa69d40ae020&#34;&gt;Pointers - some miscellaneous and important points&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#stp:a6dc26714d32df1ac6a7aa69d40ae020&#34;&gt;Setup&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#repo:a6dc26714d32df1ac6a7aa69d40ae020&#34;&gt;Get the repo&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#hdmi:a6dc26714d32df1ac6a7aa69d40ae020&#34;&gt;Disable the HDMI cape&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#pins:a6dc26714d32df1ac6a7aa69d40ae020&#34;&gt;Available pins&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#leds:a6dc26714d32df1ac6a7aa69d40ae020&#34;&gt;LEDs on P8_45&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#pcgt:a6dc26714d32df1ac6a7aa69d40ae020&#34;&gt;Setting up the PRU code generation tool&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#blin:a6dc26714d32df1ac6a7aa69d40ae020&#34;&gt;Get blinky&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#code:a6dc26714d32df1ac6a7aa69d40ae020&#34;&gt;Into the code&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#ccode:a6dc26714d32df1ac6a7aa69d40ae020&#34;&gt;The C code : PRU_gpioToggle&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;The __R31 and __R30 variables&lt;/li&gt;
&lt;li&gt;The __delay_cycles() function&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#cmd:a6dc26714d32df1ac6a7aa69d40ae020&#34;&gt;The linker file : PRU_gpioToggle/AM335x_PRU.cmd&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#desh:a6dc26714d32df1ac6a7aa69d40ae020&#34;&gt;The deploy script : deploy.sh&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#nxt:a6dc26714d32df1ac6a7aa69d40ae020&#34;&gt;Whats next ?&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;ptr:a6dc26714d32df1ac6a7aa69d40ae020&#34;&gt;&lt;u&gt;Pointers&lt;/u&gt;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;We will be dealing with latest kernels. The series of examples are expected to work on kernel version later than 4.4.12-ti-r31. To check what the latest kernel available is
&lt;pre class=&#34;prettyprint &#34;&gt;
$ sudo apt-get update
$ sudo apt-cache search &amp;lsquo;linux-image-&lt;em&gt;-ti-&lt;/em&gt;&amp;rsquo; | sort -V
&lt;/pre&gt;
Out of the list that now appears, assuming the latest kernel image to be 4.4.12-ti-r31
&lt;pre class=&#34;prettyprint &#34;&gt;
$ export NEW=4.4.12-ti-r31
$ sudo apt-get install -y linux-firmware-image-$NEW linux-headers-$NEW linux-image-$NEW
$ reboot
&lt;/pre&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Since we all love Linux, and its standards that support scalability, no prussdrv talks.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The example directory that we will be using is the &amp;lsquo;examples/&amp;rsquo; directory from my GSoC project &lt;a href=&#34;https://github.com/ZeekHuge/BeagleScope&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;I will be adding the code/commands for all the steps here, but to make life easier, there is always this &lt;a href=&#34;https://www.zeekhuge.me/post/a_handfull_of_commands_and_scripts_to_get_started_with_beagleboneblack/&#34;&gt;cheat sheet&lt;/a&gt;  you can refer to.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;For any experiments you do with PRUs, remember that they can source very less current. Probably about 8mA, so keep that in mind.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;https://www.zeekhuge.me/jokes/ohm.png&#34; alt=&#34;Power&#34; /&gt;&lt;/p&gt;

&lt;p&gt;picture credits : &lt;a href=&#34;https://xkcd.com&#34;&gt;xkcd.com&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Hang on throughout the series, as it might get a bit daunting at times.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;stp:a6dc26714d32df1ac6a7aa69d40ae020&#34;&gt;&lt;u&gt;Setup&lt;/u&gt;&lt;/h3&gt;

&lt;h5 id=&#34;repo:a6dc26714d32df1ac6a7aa69d40ae020&#34;&gt;&lt;u&gt;Get the repo&lt;/u&gt;&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;My GSoC 2016 project BeagleScope required understanding of PRU programming and its kernel interfacing. Since most of the things were documented in form of large PDFs I had to go through them and experiment a bit. The experiments are collected in the BeagleScop repo along with some documentation. To get the repo
&lt;pre class=&#34;prettyprint &#34;&gt;
$ git clone &lt;a href=&#34;https://github.com/ZeekHuge/BeagleScope.git&#34;&gt;https://github.com/ZeekHuge/BeagleScope.git&lt;/a&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h5 id=&#34;hdmi:a6dc26714d32df1ac6a7aa69d40ae020&#34;&gt;&lt;u&gt;Disable the HDMI cape&lt;/u&gt;&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;Why disable the HDMI cape ? Well, not all the pins of the PRUs are routed to the boards header pins. The max number of PRU pins in any case you can get is about 28 out of 64 pins, and most of the output pins happen to be routed to P8 header and associated to PRU1. But then, by default HDMI cape is loaded, which actually uses these pins, making it unstable to be used for PRUs. This pic of the &lt;a href=&#34;https://github.com/ZeekHuge/BeagleScope/blob/port_to_4.4.12-ti-r31%2B/docs/BeagleboneBlackP8HeaderTable.pdf&#34;&gt;BeagleScope/docs/BeagleboneBlackP8HeaderTable.pdf&lt;/a&gt; shows the pin numbers that we get after we disable the HDMI cape:

&lt;figure &gt;
    
        &lt;img src=&#34;https://www.zeekhuge.me/images/hdmi_pins.png&#34; width=&#34;1000&#34; /&gt;
    
    
    &lt;figcaption&gt;
        &lt;h4&gt;P8 pins : muxed to hdmi by default&lt;/h4&gt;
        
    &lt;/figcaption&gt;
    
&lt;/figure&gt;

So disabling it is the best option. To disable the cape, you need to edit your &amp;lsquo;/boot/uEnv.txt&amp;rsquo; file and uncomment
&lt;pre class=&#34;prettyprint &#34;&gt;
dtb=am335x-boneblack-emmc-overlay.dtb
&lt;/pre&gt;
the first few lines of your &amp;lsquo;/boot/uEnv.txt&amp;rsquo; would then look something like this :
&lt;pre class=&#34;prettyprint &#34;&gt;
01 #Docs: &lt;a href=&#34;http://elinux.org/Beagleboard:U-boot_partitioning_layout_2.0&#34;&gt;http://elinux.org/Beagleboard:U-boot_partitioning_layout_2.0&lt;/a&gt;
02
03 uname_r=4.4.12-ti-r31
04 ##uuid=
05 #dtb=
06
07 ##BeagleBone Black/Green dtbs for v4.1.x (BeagleBone White just works..)
08
09 ##BeagleBone Black: HDMI (Audio/Video) disabled:
10 dtb=am335x-boneblack-emmc-overlay.dtb
11 ##BeagleBone Black: eMMC disabled:
12 #dtb=am335x-boneblack-hdmi-overlay.dtb
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h5 id=&#34;pins:a6dc26714d32df1ac6a7aa69d40ae020&#34;&gt;&lt;u&gt;Available pins&lt;/u&gt;&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;So after disabling the HDMI cape, we have a few pins to use for PRU examples on P8 header. At this point you might want to note the pins that we can use the. You can use this doc at &lt;a href=&#34;https://github.com/ZeekHuge/BeagleScope/blob/port_to_4.4.12-ti-r31%2B/docs/BeagleboneBlackP8HeaderTable.pdf&#34;&gt;BeagleScope/docs/BeagleboneBlackP8HeaderTable.pdf&lt;/a&gt;:

&lt;figure &gt;
    
        &lt;img src=&#34;https://www.zeekhuge.me/images/pru_pins_p8.png&#34; width=&#34;1000&#34; /&gt;
    
    
    &lt;figcaption&gt;
        &lt;h4&gt;P8 pins : Associated to PRU1&lt;/h4&gt;
        
    &lt;/figcaption&gt;
    
&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h5 id=&#34;leds:a6dc26714d32df1ac6a7aa69d40ae020&#34;&gt;&lt;u&gt;LEDs on P8_45&lt;/u&gt;&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;em&gt;Read this carefully&lt;/em&gt;&lt;/strong&gt;*. The blinky we are aiming to get will be using an external LED. ***NOW, THIS EXTERNAL LED SHOULD NOT USE CURRENT MORE THAN ~8mA, AND FOR THIS, AT 3.3V, &lt;strong&gt;&lt;em&gt;THE RESISTOR TO BE USED SHOULD BE GREATER THAN OR EQUAL TO 470 ohms&lt;/em&gt;&lt;/strong&gt;. If you would want to the get more current out of it, checkout &lt;a href=&#34;http://www.thebrokendesk.com/post/blinking-an-led-with-the-beaglebone-black/&#34;&gt;this link&lt;/a&gt;. Connect this LED you have now, using a &amp;gt;=470 ohm resistor, to the P8_45 pin on the beaglebone black board.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h5 id=&#34;pcgt:a6dc26714d32df1ac6a7aa69d40ae020&#34;&gt;&lt;u&gt;Setting up the PRU code generation tools&lt;/u&gt;&lt;/h5&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;The PRUs are not like the other standard processors. PRUs are based on TI&amp;rsquo;s proprietor architecture, and therefore we need a compiler other than GCC to compile code for PRUs. To download the code generation tools on your BBB(recommended) :
&lt;pre class=&#34;prettyprint&#34;&gt;
$ wget -c &lt;a href=&#34;http://software-dl.ti.com/codegen/esd/cgt_public_sw/PRU/2.1.2/ti_cgt_pru_2.1.2_armlinuxa8hf_busybox_installer.sh&#34;&gt;http://software-dl.ti.com/codegen/esd/cgt_public_sw/PRU/2.1.2/ti_cgt_pru_2.1.2_armlinuxa8hf_busybox_installer.sh&lt;/a&gt;
$ chmod +x ti_cgt_pru_2.1.2_armlinuxa8hf_busybox_installer.sh
$ ./ti_cgt_pru_2.1.2_armlinuxa8hf_busybox_installer.sh
&lt;/pre&gt;
To download it on you linux host system
&lt;pre class=&#34;prettyprint&#34;&gt;
$ wget -c &lt;a href=&#34;http://software-dl.ti.com/codegen/esd/cgt_public_sw/PRU/2.1.2/ti_cgt_pru_2.1.2_linux_installer_x86.bin&#34;&gt;http://software-dl.ti.com/codegen/esd/cgt_public_sw/PRU/2.1.2/ti_cgt_pru_2.1.2_linux_installer_x86.bin&lt;/a&gt;
$ chmod +x ti_cgt_pru_2.1.2_linux_installer_x86.bin
$ ./ti_cgt_pru_2.1.2_armlinuxa8hf_busybox_installer.sh
&lt;/pre&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;To setup the environment, we need to create some symbolic links and export some environment variables. The symbolic links will help us to keep things at one place, and that is, inside the /usr/share/cgt-pru/. The symbolic links target to the&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;clpru - The PRU c compiler&lt;/li&gt;
&lt;li&gt;lnkpru - The PRU linker
&lt;pre class=&#34;prettyprint&#34;&gt;
$ ln -s /usr/bin/clpru /usr/share/ti/cgt-pru/bin/clpru
$ ln -s /usr/bin/lnkpru /usr/share/ti/cgt-pru/bin/lnkpru
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;We need the environment variable &amp;lsquo;PRU_CGT&amp;rsquo; to point to the &amp;lsquo;/usr/share/ti/cgt-pru/&amp;rsquo; directory. This is pretty straight forward, just:
&lt;pre class=&#34;prettyprint&#34;&gt;
$ export PRU_CGT=/usr/share/ti/cgt-pru
&lt;/pre&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;If you want this to be done automatically when you start a terminal on bbb, just add the above line to &amp;lsquo;~/.bash.rc&amp;rsquo;. Once all this is done, you can test your setup:
&lt;pre class=&#34;prettyprint&#34;&gt;
$ $PRU_CGT/bin/clpru
&lt;/pre&gt;
And a list of help options would appear.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h5 id=&#34;blin:a6dc26714d32df1ac6a7aa69d40ae020&#34;&gt;&lt;u&gt;Get blinky&lt;/u&gt;&lt;/h5&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;To get to the example we are going to use, you will have to get into the examples :
$ cd BeagleScope/examples/firmware_exmples/pru_blinky/&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Now that you are at the example, just:
&lt;pre class=&#34;prettyprint&#34;&gt;
$ ./deploy.sh
&lt;/pre&gt;
&lt;em&gt;and WHOLA ! You have the led blinking at P8_45.&lt;/em&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;code:a6dc26714d32df1ac6a7aa69d40ae020&#34;&gt;&lt;u&gt;Into the code&lt;/u&gt;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;For this post, we will dive into the PRU_gpioToggle/PRU_gpioToggle.c, PRU_gpioToggle/AM335x_PRU.cmd file and the deploy.sh script. We will get into the Makefile and the resource table in future post.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h5 id=&#34;ccode:a6dc26714d32df1ac6a7aa69d40ae020&#34;&gt;&lt;u&gt;The C code : PRU_gpioToggle.c&lt;/u&gt;&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;So here is the &lt;a href=&#34;https://github.com/ZeekHuge/BeagleScope/blob/port_to_4.4.12-ti-r31%2B/examples/firmware_exmples/pru_blinky/PRU_gpioToggle/PRU_gpioToggle.c&#34;&gt;code&lt;/a&gt; and its pretty straight forward .But there are two things I would like to discuss here :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;The __R31 and __R30 variables
The two lines in the code :
&lt;pre class=&#34;prettyprint&#34;&gt;
volatile register uint32_t __R30;
volatile register uint32_t __R31;
&lt;/pre&gt;
declares the global register variables __R30 and __R31.  One may think that any of the PRUs register could be accessed by using a variable of &amp;lsquo;register&amp;rsquo; type, but that is not true with C/C++. The special thing about this is, the clpru (compiler we are using) can only have __R30 and __R31 as the variable of register type. The compiler would not allow the any variable other than __R31 and __R30 to be of the &amp;lsquo;register&amp;rsquo; type, and the compiler do not allows to access any of the R29-R0 registers of the PRU. You may declare various variables and the PRU would manage internally, juggling all various resources (including registers), but no direct access is allowed.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The __delay_cycles() function
The __delay_cycles() function, as the name suggests, causes a delay of specified number of cycles. __delay_cycles() is an intrinsic compiler function. The term &amp;lsquo;intrinsic&amp;rsquo; means that the definition of the function is not a fixed one. The definition is handled by the compiler. This is probably because in the assembly implementation of the loop, it takes one cycle to subtract 1 from counter register and then another cycle to compare the register. This limits the delay that can be produced by one implementation, as the next counter value will be
&lt;pre class=&#34;prettyprint&#34;&gt;
counter = counter - 2
&lt;/pre&gt;
A single implementation of delay function can work either for odd number of cycles, or an even umber of cycles, but not for both.
The exact declaration of the function is as:
&lt;pre class=&#34;prettyprint&#34;&gt;
void __delay_cycles (const unsigned int cycles);
&lt;/pre&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h5 id=&#34;cmd:a6dc26714d32df1ac6a7aa69d40ae020&#34;&gt;&lt;u&gt;The linker file : PRU_gpioToggle/AM335x_PRU.cmd&lt;/u&gt;&lt;/h5&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;PRUs are pretty simple processing cores, but the PRUSS system is highly integrated and provides the PRU a rich set of peripherals. All these peripherals inside the PRUSS are at different address locations and they need to be configured by the linux kernel at the time of firmware loading onto the PRUs. The &lt;a href=&#34;https://github.com/ZeekHuge/BeagleScope/blob/port_to_4.4.12-ti-r31%2B/examples/firmware_exmples/pru_blinky/PRU_gpioToggle/AM335x_PRU.cmd&#34;&gt;AM335x_PRU.cmd file&lt;/a&gt; provides a mapping to the linker, from different sections of code, to different memory locations inside the PRUSS.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;There are 2 sections inside the AM335x_PRU.cmd file :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The &amp;lsquo;MEMORY&amp;rsquo; section
This section gives a kind of alias name to different regions of memory inside the PRUs. If you look at the code and this snippet from the PRU reference manual, you see that the mappings are indeed associated to the exact memory region of the peripherals.
&amp;lt;?prettify?&amp;gt;
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
MEMORY
{
PAGE 0:
PRU_IMEM                : org = 0x00000000 len = 0x00002000  /* 8kB PRU0 Instruction RAM */
PAGE 1:
/* RAM */
PRU_DMEM_0_1    : org = 0x00000000 len = 0x00002000 CREGISTER=24 /* 8kB PRU Data RAM 0_1 */
PRU_DMEM_1_0    : org = 0x00002000 len = 0x00002000     CREGISTER=25 /* 8kB PRU Data RAM 1_0 */
  PAGE 2:
PRU_SHAREDMEM   : org = 0x00010000 len = 0x00003000 CREGISTER=28 /* 12kB Shared RAM */
DDR                         : org = 0x80000000 len = 0x00000100 CREGISTER=31
L3OCMC                  : org = 0x40000000 len = 0x00010000     CREGISTER=30
/* Peripherals */
PRU_CFG                 : org = 0x00026000 len = 0x00000044     CREGISTER=4
PRU_ECAP                : org = 0x00030000 len = 0x00000060     CREGISTER=3
PRU_IEP                 : org = 0x0002E000 len = 0x0000031C     CREGISTER=26
PRU_INTC                : org = 0x00020000 len = 0x00001504     CREGISTER=0
PRU_UART                : org = 0x00028000 len = 0x00000038     CREGISTER=7
DCAN0                   : org = 0x481CC000 len = 0x000001E8     CREGISTER=14
DCAN1                   : org = 0x481D0000 len = 0x000001E8     CREGISTER=15
DMTIMER2                : org = 0x48040000 len = 0x0000005C     CREGISTER=1
PWMSS0                  : org = 0x48300000 len = 0x000002C4     CREGISTER=18
PWMSS1                  : org = 0x48302000 len = 0x000002C4     CREGISTER=19
PWMSS2                  : org = 0x48304000 len = 0x000002C4     CREGISTER=20
GEMAC                   : org = 0x4A100000 len = 0x0000128C     CREGISTER=9
I2C1                    : org = 0x4802A000 len = 0x000000D8     CREGISTER=2
I2C2                    : org = 0x4819C000 len = 0x000000D8     CREGISTER=17
MBX0                    : org = 0x480C8000 len = 0x00000140     CREGISTER=22
MCASP0_DMA              : org = 0x46000000 len = 0x00000100     CREGISTER=8
MCSPI0                  : org = 0x48030000 len = 0x000001A4     CREGISTER=6
MCSPI1                  : org = 0x481A0000 len = 0x000001A4     CREGISTER=16
MMCHS0                  : org = 0x48060000 len = 0x00000300     CREGISTER=5
SPINLOCK                : org = 0x480CA000 len = 0x00000880     CREGISTER=23
TPCC                    : org = 0x49000000 len = 0x00001098     CREGISTER=29
UART1                   : org = 0x48022000 len = 0x00000088     CREGISTER=11
UART2                   : org = 0x48024000 len = 0x00000088     CREGISTER=12
RSVD10                  : org = 0x48318000 len = 0x00000100     CREGISTER=10
RSVD13                  : org = 0x48310000 len = 0x00000100     CREGISTER=13
RSVD21                  : org = 0x00032400 len = 0x00000100     CREGISTER=21
RSVD27                  : org = 0x00032000 len = 0x00000100     CREGISTER=27
}
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;https://www.zeekhuge.me/images/memory_mapping.png&#34; width=&#34;1000&#34; /&gt;
    
    
    &lt;figcaption&gt;
        &lt;h4&gt;PRUSS Memory locations&lt;/h4&gt;
        
    &lt;/figcaption&gt;
    
&lt;/figure&gt;


&lt;hr /&gt;

&lt;h5 id=&#34;desh:a6dc26714d32df1ac6a7aa69d40ae020&#34;&gt;&lt;u&gt;The deploy script : deploy.sh&lt;/u&gt;&lt;/h5&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;The deploy script, in this example does following things :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&amp;lsquo;make&amp;rsquo;s the pru code.
That is simple, the part of the script included below enters the PRU_gpioToggle and invokes the &amp;lsquo;make&amp;rsquo; command to make the project.
&lt;pre class=&#34;prettyprint&#34;&gt;
54 echo &amp;ldquo;-Building project&amp;rdquo;
55 cd PRU_gpioToggle
56 make clean
57 make
&lt;/pre&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Copies the compiled pru firmware file (the file gen/&lt;em&gt;.out) to /lib/firmware/am335x-pru1-fw. When the PRUs are rebooted, the pru_rproc (remoteproc driver for PRUs) search for this file ans load it onto the PRU is it is present.
The part of the script that does this is :
&lt;pre class=&#34;prettyprint&#34;&gt;
59 echo &amp;ldquo;-Placing the firmware&amp;rdquo;
60 cp gen/&lt;/em&gt;.out /lib/firmware/am335x-pru$PRU_CORE-fw
&lt;/pre&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Configures the header pin.
The script has two variables - 1) HEADER and 2) PIN_NUMBER. They together decide the boards header pin that is to be used and you can change them to get blinky on other pin (mind the comments above these variables in the script). The header pin is then configured and muxed to be a pru output pin. The script uses a very nice utility called &amp;lsquo;config-pin&amp;rsquo; and an which, very intelligently uses a Universal cape to configure pins without using a device tree file. More about &amp;lsquo;config-pin&amp;rsquo; can be found &lt;a href=&#34;https://www.zeekhuge.me/post/a_handfull_of_commands_and_scripts_to_get_started_with_beagleboneblack/&#34;&gt;here&lt;/a&gt;. The part of the script that configures the pin is :
&lt;pre class=&#34;prettyprint&#34;&gt;
62 echo &amp;ldquo;-Configuring pinmux&amp;rdquo;
63         config-pin -a $HEADER$PIN_NUMBER pruout
64         config-pin -q $HEADER$PIN_NUMBER
&lt;/pre&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Reboots the PRU cores. After the firmwares are /lib/firmware/am335x-pru1(0)-fw is present, rebooting the PRU cores automatically loads the PRU with these firmwares. The sysfs bindings at the &amp;lsquo;/sys/bus/platform/drivers/pru-rproc/&amp;rsquo; can be used to reboot PRUs (more on this below). The part of the script that reboots the PRU core, according to the variable PRU_CORE in the script
&lt;pre class=&#34;prettyprint&#34;&gt;
66 echo &amp;ldquo;-Rebooting&amp;rdquo;
67 if [ $PRU_CORE -eq 0 ]
68 then
69         echo &amp;ldquo;Rebooting pru-core 0&amp;rdquo;
70         echo &amp;ldquo;4a334000.pru0&amp;rdquo; &amp;gt; /sys/bus/platform/drivers/pru-rproc/unbind 2&amp;gt;/dev/null
71         echo &amp;ldquo;4a334000.pru0&amp;rdquo; &amp;gt; /sys/bus/platform/drivers/pru-rproc/bind
72 else
73         echo &amp;ldquo;Rebooting pru-core 1&amp;rdquo;
74         echo &amp;ldquo;4a338000.pru1&amp;rdquo; &amp;gt; /sys/bus/platform/drivers/pru-rproc/unbind 2&amp;gt; /dev/null
75         echo &amp;ldquo;4a338000.pru1&amp;rdquo; &amp;gt; /sys/bus/platform/drivers/pru-rproc/bind
76 fi
&lt;/pre&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;nxt:a6dc26714d32df1ac6a7aa69d40ae020&#34;&gt;&lt;u&gt;Whats next ?&lt;/u&gt;&lt;/h3&gt;

&lt;p&gt;OK, so now you have a blinky ready and have got quite understanding of the PRUSS part. The next post will be related to &lt;a href=&#34;https://www.zeekhuge.me/post/ptp_docs_commands_and_tools&#34;&gt;Tools and Commands&lt;/a&gt; that use while eperimenting with PRUs. They really make working with them easier.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>PTP - Programming The PRUs 1: Blinky</title>
      <link>https://www.zeekhuge.me/post/ptp_series/ptp_blinky/</link>
      <pubDate>Sat, 16 Jul 2016 15:45:08 +0530</pubDate>
      
      <guid>https://www.zeekhuge.me/post/ptp_series/ptp_blinky/</guid>
      <description>

&lt;p&gt;&lt;strong&gt;This is the first post in a series of posts that will try to put the PRU programming process in the simplest and the most logical form, connecting all the dots (rpmsg, remoteproc etc). The posts of this series will have PTP (Programming The Pru) at the beginning of its title. As its just the beginning, this post aims to get you a blinky application using PRUs on your BeagleBone Black.&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;u-preface-u:a6dc26714d32df1ac6a7aa69d40ae020&#34;&gt;&lt;u&gt;Preface&lt;/u&gt;&lt;/h3&gt;

&lt;p&gt;Some people may say, &lt;em&gt;&amp;ldquo;Really ? A blinky ? Are you kidding me ? If someone is trying to get started with PRUs, he/she&amp;rsquo;s most probably well acquainted to the concept of embedded programming.&amp;rdquo;&lt;/em&gt;, to them, I would just say &lt;em&gt;&amp;ldquo;yes, a blinky.&amp;rdquo;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;However experienced an embedded programmer is, blinky can still be the most thrilling application that he develops. It is thrilling at least to me, and I just put my hands up in the air like I have won a war. Further, this post will help you get all the things at the right place to begin with more complex examples. If you still don&amp;rsquo;t think its worth it, well, Its my post :P&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;u-content-u:a6dc26714d32df1ac6a7aa69d40ae020&#34;&gt;&lt;u&gt;Content&lt;/u&gt;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#ptr:a6dc26714d32df1ac6a7aa69d40ae020&#34;&gt;Pointers - some random and important points&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#stp:a6dc26714d32df1ac6a7aa69d40ae020&#34;&gt;Setup&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#repo:a6dc26714d32df1ac6a7aa69d40ae020&#34;&gt;Get the repo&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#hdmi:a6dc26714d32df1ac6a7aa69d40ae020&#34;&gt;Disable the HDMI cape&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#pins:a6dc26714d32df1ac6a7aa69d40ae020&#34;&gt;Available pins&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#leds:a6dc26714d32df1ac6a7aa69d40ae020&#34;&gt;LEDs on P8_45&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#pcgt:a6dc26714d32df1ac6a7aa69d40ae020&#34;&gt;Setting up the PRU code generation tool&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#blin:a6dc26714d32df1ac6a7aa69d40ae020&#34;&gt;Get blinky&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#code:a6dc26714d32df1ac6a7aa69d40ae020&#34;&gt;Into the code&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#ccode:a6dc26714d32df1ac6a7aa69d40ae020&#34;&gt;The C code : PRU_gpioToggle&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;The __R31 and __R30 variables&lt;/li&gt;
&lt;li&gt;The __delay_cycles() function&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#cmd:a6dc26714d32df1ac6a7aa69d40ae020&#34;&gt;The linker file : PRU_gpioToggle/AM335x_PRU.cmd&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#desh:a6dc26714d32df1ac6a7aa69d40ae020&#34;&gt;The deploy script : deploy.sh&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#nxt:a6dc26714d32df1ac6a7aa69d40ae020&#34;&gt;Whats next ?&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;ptr:a6dc26714d32df1ac6a7aa69d40ae020&#34;&gt;&lt;u&gt;Pointers&lt;/u&gt;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;We will be dealing with latest kernels. The series of examples are expected to work on kernel version later than 4.4.12-ti-r31. To check what the latest kernel available is
&lt;pre class=&#34;prettyprint &#34;&gt;
$ sudo apt-get update
$ sudo apt-cache search &amp;lsquo;linux-image-&lt;em&gt;-ti-&lt;/em&gt;&amp;rsquo; | sort -V
&lt;/pre&gt;
Out of the list that now appears, assuming the latest kernel image to be 4.4.12-ti-r31
&lt;pre class=&#34;prettyprint &#34;&gt;
$ export NEW=4.4.12-ti-r31
$ sudo apt-get install -y linux-firmware-image-$NEW linux-headers-$NEW linux-image-$NEW
$ reboot
&lt;/pre&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Since we all love Linux, and its standards that support scalability, no prussdrv talks.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The example directory that we will be using is the &amp;lsquo;examples/&amp;rsquo; directory from my GSoC project &lt;a href=&#34;https://github.com/ZeekHuge/BeagleScope&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;I will be adding the code/commands for all the steps here, but to make life easier, there is always this &lt;a href=&#34;https://www.zeekhuge.me/post/a_handfull_of_commands_and_scripts_to_get_started_with_beagleboneblack/&#34;&gt;cheat sheet&lt;/a&gt;  you can refer to.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;For any experiments you do with PRUs, remember that they can source very less current. Probably about 8mA, so keep that in mind.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;https://www.zeekhuge.me/jokes/ohm.png&#34; alt=&#34;Power&#34; /&gt;&lt;/p&gt;

&lt;p&gt;picture credits : &lt;a href=&#34;https://xkcd.com&#34;&gt;xkcd.com&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Hang on throughout the series, as it might get a bit daunting at times.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;stp:a6dc26714d32df1ac6a7aa69d40ae020&#34;&gt;&lt;u&gt;Setup&lt;/u&gt;&lt;/h3&gt;

&lt;h5 id=&#34;repo:a6dc26714d32df1ac6a7aa69d40ae020&#34;&gt;&lt;u&gt;Get the repo&lt;/u&gt;&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;My GSoC 2016 project BeagleScope required understanding of PRU programming and its kernel interfacing. Since most of the things were documented in form of large PDFs I had to go through them and experiment a bit. The experiments are collected in the BeagleScop repo along with some documentation. To get the repo
&lt;pre class=&#34;prettyprint &#34;&gt;
$ git clone &lt;a href=&#34;https://github.com/ZeekHuge/BeagleScope.git&#34;&gt;https://github.com/ZeekHuge/BeagleScope.git&lt;/a&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h5 id=&#34;hdmi:a6dc26714d32df1ac6a7aa69d40ae020&#34;&gt;&lt;u&gt;Disable the HDMI cape&lt;/u&gt;&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;Why disable the HDMI cape ? Well, not all the pins of the PRUs are routed to the boards header pins. The max number of PRU pins in any case you can get is about 28 out of 64 pins, and most of the output pins happen to be routed to P8 header and associated to PRU1. But then, by default HDMI cape is loaded, which actually uses these pins, making it unstable to be used for PRUs. This pic of the &lt;a href=&#34;https://github.com/ZeekHuge/BeagleScope/blob/port_to_4.4.12-ti-r31%2B/docs/BeagleboneBlackP8HeaderTable.pdf&#34;&gt;BeagleScope/docs/BeagleboneBlackP8HeaderTable.pdf&lt;/a&gt; shows the pin numbers that we get after we disable the HDMI cape:

&lt;figure &gt;
    
        &lt;img src=&#34;https://www.zeekhuge.me/images/hdmi_pins.png&#34; width=&#34;1000&#34; /&gt;
    
    
    &lt;figcaption&gt;
        &lt;h4&gt;P8 pins : muxed to hdmi by default&lt;/h4&gt;
        
    &lt;/figcaption&gt;
    
&lt;/figure&gt;

So disabling it is the best option. To disable the cape, you need to edit your &amp;lsquo;/boot/uEnv.txt&amp;rsquo; file and uncomment
&lt;pre class=&#34;prettyprint &#34;&gt;
dtb=am335x-boneblack-emmc-overlay.dtb
&lt;/pre&gt;
the first few lines of your &amp;lsquo;/boot/uEnv.txt&amp;rsquo; would then look something like this :
&lt;pre class=&#34;prettyprint &#34;&gt;
01 #Docs: &lt;a href=&#34;http://elinux.org/Beagleboard:U-boot_partitioning_layout_2.0&#34;&gt;http://elinux.org/Beagleboard:U-boot_partitioning_layout_2.0&lt;/a&gt;
02
03 uname_r=4.4.12-ti-r31
04 ##uuid=
05 #dtb=
06
07 ##BeagleBone Black/Green dtbs for v4.1.x (BeagleBone White just works..)
08
09 ##BeagleBone Black: HDMI (Audio/Video) disabled:
10 dtb=am335x-boneblack-emmc-overlay.dtb
11 ##BeagleBone Black: eMMC disabled:
12 #dtb=am335x-boneblack-hdmi-overlay.dtb
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h5 id=&#34;pins:a6dc26714d32df1ac6a7aa69d40ae020&#34;&gt;&lt;u&gt;Available pins&lt;/u&gt;&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;So after disabling the HDMI cape, we have a few pins to use for PRU examples on P8 header. At this point you might want to note the pins that we can use the. You can use this doc at &lt;a href=&#34;https://github.com/ZeekHuge/BeagleScope/blob/port_to_4.4.12-ti-r31%2B/docs/BeagleboneBlackP8HeaderTable.pdf&#34;&gt;BeagleScope/docs/BeagleboneBlackP8HeaderTable.pdf&lt;/a&gt;:

&lt;figure &gt;
    
        &lt;img src=&#34;https://www.zeekhuge.me/images/pru_pins_p8.png&#34; width=&#34;1000&#34; /&gt;
    
    
    &lt;figcaption&gt;
        &lt;h4&gt;P8 pins : Associated to PRU1&lt;/h4&gt;
        
    &lt;/figcaption&gt;
    
&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h5 id=&#34;leds:a6dc26714d32df1ac6a7aa69d40ae020&#34;&gt;&lt;u&gt;LEDs on P8_45&lt;/u&gt;&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;em&gt;Read this carefully&lt;/em&gt;&lt;/strong&gt;*. The blinky we are aiming to get will be using an external LED. ***NOW, THIS EXTERNAL LED SHOULD NOT USE CURRENT MORE THAN ~8mA, AND FOR THIS, AT 3.3V, &lt;strong&gt;&lt;em&gt;THE RESISTOR TO BE USED SHOULD BE GREATER THAN OR EQUAL TO 470 ohms&lt;/em&gt;&lt;/strong&gt;. If you would want to the get more current out of it, checkout &lt;a href=&#34;http://www.thebrokendesk.com/post/blinking-an-led-with-the-beaglebone-black/&#34;&gt;this link&lt;/a&gt;. Connect this LED you have now, using a &amp;gt;=470 ohm resistor, to the P8_45 pin on the beaglebone black board.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h5 id=&#34;pcgt:a6dc26714d32df1ac6a7aa69d40ae020&#34;&gt;&lt;u&gt;Setting up the PRU code generation tools&lt;/u&gt;&lt;/h5&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;The PRUs are not like the other standard processors. PRUs are based on TI&amp;rsquo;s proprietor architecture, and therefore we need a compiler other than GCC to compile code for PRUs. To download the code generation tools on your BBB(recommended) :
&lt;pre class=&#34;prettyprint&#34;&gt;
$ wget -c &lt;a href=&#34;http://software-dl.ti.com/codegen/esd/cgt_public_sw/PRU/2.1.2/ti_cgt_pru_2.1.2_armlinuxa8hf_busybox_installer.sh&#34;&gt;http://software-dl.ti.com/codegen/esd/cgt_public_sw/PRU/2.1.2/ti_cgt_pru_2.1.2_armlinuxa8hf_busybox_installer.sh&lt;/a&gt;
$ chmod +x ti_cgt_pru_2.1.2_armlinuxa8hf_busybox_installer.sh
$ ./ti_cgt_pru_2.1.2_armlinuxa8hf_busybox_installer.sh
&lt;/pre&gt;
To download it on you linux host system
&lt;pre class=&#34;prettyprint&#34;&gt;
$ wget -c &lt;a href=&#34;http://software-dl.ti.com/codegen/esd/cgt_public_sw/PRU/2.1.2/ti_cgt_pru_2.1.2_linux_installer_x86.bin&#34;&gt;http://software-dl.ti.com/codegen/esd/cgt_public_sw/PRU/2.1.2/ti_cgt_pru_2.1.2_linux_installer_x86.bin&lt;/a&gt;
$ chmod +x ti_cgt_pru_2.1.2_linux_installer_x86.bin
$ ./ti_cgt_pru_2.1.2_armlinuxa8hf_busybox_installer.sh
&lt;/pre&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;To setup the environment, we need to create some symbolic links and export some environment variables. The symbolic links will help us to keep things at one place, and that is, inside the /usr/share/cgt-pru/. The symbolic links target to the&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;clpru - The PRU c compiler&lt;/li&gt;
&lt;li&gt;lnkpru - The PRU linker
&lt;pre class=&#34;prettyprint&#34;&gt;
$ ln -s /usr/bin/clpru /usr/share/ti/cgt-pru/bin/clpru
$ ln -s /usr/bin/lnkpru /usr/share/ti/cgt-pru/bin/lnkpru
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;We need the environment variable &amp;lsquo;PRU_CGT&amp;rsquo; to point to the &amp;lsquo;/usr/share/ti/cgt-pru/&amp;rsquo; directory. This is pretty straight forward, just:
&lt;pre class=&#34;prettyprint&#34;&gt;
$ export PRU_CGT=/usr/share/ti/cgt-pru
&lt;/pre&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;If you want this to be done automatically when you start a terminal on bbb, just add the above line to &amp;lsquo;~/.bash.rc&amp;rsquo;. Once all this is done, you can test your setup:
&lt;pre class=&#34;prettyprint&#34;&gt;
$ $PRU_CGT/bin/clpru
&lt;/pre&gt;
And a list of help options would appear.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h5 id=&#34;blin:a6dc26714d32df1ac6a7aa69d40ae020&#34;&gt;&lt;u&gt;Get blinky&lt;/u&gt;&lt;/h5&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;To get to the example we are going to use, you will have to get into the examples :
$ cd BeagleScope/examples/firmware_exmples/pru_blinky/&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Now that you are at the example, just:
&lt;pre class=&#34;prettyprint&#34;&gt;
$ ./deploy.sh
&lt;/pre&gt;
&lt;em&gt;and WHOLA ! You have the led blinking at P8_45.&lt;/em&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;code:a6dc26714d32df1ac6a7aa69d40ae020&#34;&gt;&lt;u&gt;Into the code&lt;/u&gt;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;For this post, we will dive into the PRU_gpioToggle/PRU_gpioToggle.c, PRU_gpioToggle/AM335x_PRU.cmd file and the deploy.sh script. We will get into the Makefile and the resource table in future post.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h5 id=&#34;ccode:a6dc26714d32df1ac6a7aa69d40ae020&#34;&gt;&lt;u&gt;The C code : PRU_gpioToggle.c&lt;/u&gt;&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;So here is the &lt;a href=&#34;https://github.com/ZeekHuge/BeagleScope/blob/port_to_4.4.12-ti-r31%2B/examples/firmware_exmples/pru_blinky/PRU_gpioToggle/PRU_gpioToggle.c&#34;&gt;code&lt;/a&gt; and its pretty straight forward .But there are two things I would like to discuss here :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;The __R31 and __R30 variables
The two lines in the code :
&lt;pre class=&#34;prettyprint&#34;&gt;
volatile register uint32_t __R30;
volatile register uint32_t __R31;
&lt;/pre&gt;
declares the global register variables __R30 and __R31.  One may think that any of the PRUs register could be accessed by using a variable of &amp;lsquo;register&amp;rsquo; type, but that is not true with C/C++. The special thing about this is, the clpru (compiler we are using) can only have __R30 and __R31 as the variable of register type. The compiler would not allow the any variable other than __R31 and __R30 to be of the &amp;lsquo;register&amp;rsquo; type, and the compiler do not allows to access any of the R29-R0 registers of the PRU. You may declare various variables and the PRU would manage internally, juggling all various resources (including registers), but no direct access is allowed.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The __delay_cycles() function
The __delay_cycles() function, as the name suggests, causes a delay of specified number of cycles. __delay_cycles() is an intrinsic compiler function. The term &amp;lsquo;intrinsic&amp;rsquo; means that the definition of the function is not a fixed one. The definition is handled by the compiler. This is probably because in the assembly implementation of the loop, it takes one cycle to subtract 1 from counter register and then another cycle to compare the register. This limits the delay that can be produced by one implementation, as the next counter value will be
&lt;pre class=&#34;prettyprint&#34;&gt;
counter = counter - 2
&lt;/pre&gt;
A single implementation of delay function can work either for odd number of cycles, or an even umber of cycles, but not for both.
The exact declaration of the function is as:
&lt;pre class=&#34;prettyprint&#34;&gt;
void __delay_cycles (const unsigned int cycles);
&lt;/pre&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h5 id=&#34;cmd:a6dc26714d32df1ac6a7aa69d40ae020&#34;&gt;&lt;u&gt;The linker file : PRU_gpioToggle/AM335x_PRU.cmd&lt;/u&gt;&lt;/h5&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;PRUs are pretty simple processing cores, but the PRUSS system is highly integrated and provides the PRU a rich set of peripherals. All these peripherals inside the PRUSS are at different address locations and they need to be configured by the linux kernel at the time of firmware loading onto the PRUs. The &lt;a href=&#34;https://github.com/ZeekHuge/BeagleScope/blob/port_to_4.4.12-ti-r31%2B/examples/firmware_exmples/pru_blinky/PRU_gpioToggle/AM335x_PRU.cmd&#34;&gt;AM335x_PRU.cmd file&lt;/a&gt; provides a mapping to the linker, from different sections of code, to different memory locations inside the PRUSS.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;There are 2 sections inside the AM335x_PRU.cmd file :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The &amp;lsquo;MEMORY&amp;rsquo; section
This section gives a kind of alias name to different regions of memory inside the PRUs. If you look at the code and this snippet from the PRU reference manual, you see that the mappings are indeed associated to the exact memory region of the peripherals.
&amp;lt;?prettify?&amp;gt;
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
MEMORY
{
PAGE 0:
PRU_IMEM                : org = 0x00000000 len = 0x00002000  /* 8kB PRU0 Instruction RAM */
PAGE 1:
/* RAM */
PRU_DMEM_0_1    : org = 0x00000000 len = 0x00002000 CREGISTER=24 /* 8kB PRU Data RAM 0_1 */
PRU_DMEM_1_0    : org = 0x00002000 len = 0x00002000     CREGISTER=25 /* 8kB PRU Data RAM 1_0 */
  PAGE 2:
PRU_SHAREDMEM   : org = 0x00010000 len = 0x00003000 CREGISTER=28 /* 12kB Shared RAM */
DDR                         : org = 0x80000000 len = 0x00000100 CREGISTER=31
L3OCMC                  : org = 0x40000000 len = 0x00010000     CREGISTER=30
/* Peripherals */
PRU_CFG                 : org = 0x00026000 len = 0x00000044     CREGISTER=4
PRU_ECAP                : org = 0x00030000 len = 0x00000060     CREGISTER=3
PRU_IEP                 : org = 0x0002E000 len = 0x0000031C     CREGISTER=26
PRU_INTC                : org = 0x00020000 len = 0x00001504     CREGISTER=0
PRU_UART                : org = 0x00028000 len = 0x00000038     CREGISTER=7
DCAN0                   : org = 0x481CC000 len = 0x000001E8     CREGISTER=14
DCAN1                   : org = 0x481D0000 len = 0x000001E8     CREGISTER=15
DMTIMER2                : org = 0x48040000 len = 0x0000005C     CREGISTER=1
PWMSS0                  : org = 0x48300000 len = 0x000002C4     CREGISTER=18
PWMSS1                  : org = 0x48302000 len = 0x000002C4     CREGISTER=19
PWMSS2                  : org = 0x48304000 len = 0x000002C4     CREGISTER=20
GEMAC                   : org = 0x4A100000 len = 0x0000128C     CREGISTER=9
I2C1                    : org = 0x4802A000 len = 0x000000D8     CREGISTER=2
I2C2                    : org = 0x4819C000 len = 0x000000D8     CREGISTER=17
MBX0                    : org = 0x480C8000 len = 0x00000140     CREGISTER=22
MCASP0_DMA              : org = 0x46000000 len = 0x00000100     CREGISTER=8
MCSPI0                  : org = 0x48030000 len = 0x000001A4     CREGISTER=6
MCSPI1                  : org = 0x481A0000 len = 0x000001A4     CREGISTER=16
MMCHS0                  : org = 0x48060000 len = 0x00000300     CREGISTER=5
SPINLOCK                : org = 0x480CA000 len = 0x00000880     CREGISTER=23
TPCC                    : org = 0x49000000 len = 0x00001098     CREGISTER=29
UART1                   : org = 0x48022000 len = 0x00000088     CREGISTER=11
UART2                   : org = 0x48024000 len = 0x00000088     CREGISTER=12
RSVD10                  : org = 0x48318000 len = 0x00000100     CREGISTER=10
RSVD13                  : org = 0x48310000 len = 0x00000100     CREGISTER=13
RSVD21                  : org = 0x00032400 len = 0x00000100     CREGISTER=21
RSVD27                  : org = 0x00032000 len = 0x00000100     CREGISTER=27
}
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;https://www.zeekhuge.me/images/memory_mapping.png&#34; width=&#34;1000&#34; /&gt;
    
    
    &lt;figcaption&gt;
        &lt;h4&gt;PRUSS Memory locations&lt;/h4&gt;
        
    &lt;/figcaption&gt;
    
&lt;/figure&gt;


&lt;hr /&gt;

&lt;h5 id=&#34;desh:a6dc26714d32df1ac6a7aa69d40ae020&#34;&gt;&lt;u&gt;The deploy script : deploy.sh&lt;/u&gt;&lt;/h5&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;The deploy script, in this example does following things :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&amp;lsquo;make&amp;rsquo;s the pru code.
That is simple, the part of the script included below enters the PRU_gpioToggle and invokes the &amp;lsquo;make&amp;rsquo; command to make the project.
&lt;pre class=&#34;prettyprint&#34;&gt;
54 echo &amp;ldquo;-Building project&amp;rdquo;
55 cd PRU_gpioToggle
56 make clean
57 make
&lt;/pre&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Copies the compiled pru firmware file (the file gen/&lt;em&gt;.out) to /lib/firmware/am335x-pru1-fw. When the PRUs are rebooted, the pru_rproc (remoteproc driver for PRUs) search for this file ans load it onto the PRU is it is present.
The part of the script that does this is :
&lt;pre class=&#34;prettyprint&#34;&gt;
59 echo &amp;ldquo;-Placing the firmware&amp;rdquo;
60 cp gen/&lt;/em&gt;.out /lib/firmware/am335x-pru$PRU_CORE-fw
&lt;/pre&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Configures the header pin.
The script has two variables - 1) HEADER and 2) PIN_NUMBER. They together decide the boards header pin that is to be used and you can change them to get blinky on other pin (mind the comments above these variables in the script). The header pin is then configured and muxed to be a pru output pin. The script uses a very nice utility called &amp;lsquo;config-pin&amp;rsquo; and an which, very intelligently uses a Universal cape to configure pins without using a device tree file. More about &amp;lsquo;config-pin&amp;rsquo; can be found &lt;a href=&#34;https://www.zeekhuge.me/post/a_handfull_of_commands_and_scripts_to_get_started_with_beagleboneblack/&#34;&gt;here&lt;/a&gt;. The part of the script that configures the pin is :
&lt;pre class=&#34;prettyprint&#34;&gt;
62 echo &amp;ldquo;-Configuring pinmux&amp;rdquo;
63         config-pin -a $HEADER$PIN_NUMBER pruout
64         config-pin -q $HEADER$PIN_NUMBER
&lt;/pre&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Reboots the PRU cores. After the firmwares are /lib/firmware/am335x-pru1(0)-fw is present, rebooting the PRU cores automatically loads the PRU with these firmwares. The sysfs bindings at the &amp;lsquo;/sys/bus/platform/drivers/pru-rproc/&amp;rsquo; can be used to reboot PRUs (more on this below). The part of the script that reboots the PRU core, according to the variable PRU_CORE in the script
&lt;pre class=&#34;prettyprint&#34;&gt;
66 echo &amp;ldquo;-Rebooting&amp;rdquo;
67 if [ $PRU_CORE -eq 0 ]
68 then
69         echo &amp;ldquo;Rebooting pru-core 0&amp;rdquo;
70         echo &amp;ldquo;4a334000.pru0&amp;rdquo; &amp;gt; /sys/bus/platform/drivers/pru-rproc/unbind 2&amp;gt;/dev/null
71         echo &amp;ldquo;4a334000.pru0&amp;rdquo; &amp;gt; /sys/bus/platform/drivers/pru-rproc/bind
72 else
73         echo &amp;ldquo;Rebooting pru-core 1&amp;rdquo;
74         echo &amp;ldquo;4a338000.pru1&amp;rdquo; &amp;gt; /sys/bus/platform/drivers/pru-rproc/unbind 2&amp;gt; /dev/null
75         echo &amp;ldquo;4a338000.pru1&amp;rdquo; &amp;gt; /sys/bus/platform/drivers/pru-rproc/bind
76 fi
&lt;/pre&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;nxt:a6dc26714d32df1ac6a7aa69d40ae020&#34;&gt;&lt;u&gt;Whats next ?&lt;/u&gt;&lt;/h3&gt;

&lt;p&gt;OK, so now you have a blinky ready and have got quite understanding of the PRUSS part. The next post will be related to &lt;a href=&#34;https://www.zeekhuge.me/post/ptp_docs_commands_and_tools&#34;&gt;Tools and Commands&lt;/a&gt; that use while eperimenting with PRUs. They really make working with them easier.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Some Shots</title>
      <link>https://www.zeekhuge.me/post/some_shots/</link>
      <pubDate>Sun, 10 Jul 2016 03:00:17 +0530</pubDate>
      
      <guid>https://www.zeekhuge.me/post/some_shots/</guid>
      <description>

&lt;p&gt;BeagleScope project can be found &lt;a href=&#34;https://github.com/ZeekHuge/BeagleScope&#34;&gt;here&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;some-shots:0c26a2495997b81bc3012ac9e5454c14&#34;&gt;Some Shots&lt;/h3&gt;

&lt;p&gt;These are are some clicks of the hardware setup that I am going to use for the beaglescope project.&lt;/p&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;https://www.zeekhuge.me/images/pic1_bbb_power.jpg&#34; width=&#34;1000&#34; /&gt;
    
    
    &lt;figcaption&gt;
        &lt;h4&gt;Pic 1 : BBB power supply&lt;/h4&gt;
        
    &lt;/figcaption&gt;
    
&lt;/figure&gt;



&lt;figure &gt;
    
        &lt;img src=&#34;https://www.zeekhuge.me/images/pic2_adc_power_cnnct.jpg&#34; width=&#34;1000&#34; /&gt;
    
    
    &lt;figcaption&gt;
        &lt;h4&gt;Pic 2 : ADC power connections&lt;/h4&gt;
        
    &lt;/figcaption&gt;
    
&lt;/figure&gt;


&lt;p&gt;
&lt;figure &gt;
    
        &lt;img src=&#34;https://www.zeekhuge.me/images/pic3_adc_power_src.jpg&#34; width=&#34;1000&#34; /&gt;
    
    
    &lt;figcaption&gt;
        &lt;h4&gt;Pic 3 : ADC power source &lt;/h4&gt;
        
    &lt;/figcaption&gt;
    
&lt;/figure&gt;
&lt;/p&gt;

&lt;p&gt;
&lt;figure &gt;
    
        &lt;img src=&#34;https://www.zeekhuge.me/images/pic4_smthing_like_cape.jpg&#34; width=&#34;1000&#34; /&gt;
    
    
    &lt;figcaption&gt;
        &lt;h4&gt;Pic 4 : Something like a cape &lt;/h4&gt;
        
    &lt;/figcaption&gt;
    
&lt;/figure&gt;
&lt;/p&gt;

&lt;p&gt;
&lt;figure &gt;
    
        &lt;img src=&#34;https://www.zeekhuge.me/images/pic5_overlay_bbb.jpg&#34; width=&#34;1000&#34; /&gt;
    
    
    &lt;figcaption&gt;
        &lt;h4&gt;Pic 5 : The connections of &amp;#39;something like a cape&amp;#39;&lt;/h4&gt;
        
    &lt;/figcaption&gt;
    
&lt;/figure&gt;
&lt;/p&gt;

&lt;p&gt;
&lt;figure &gt;
    
        &lt;img src=&#34;https://www.zeekhuge.me/images/pic6_adc_connectors.jpg&#34; width=&#34;1000&#34; /&gt;
    
    
    &lt;figcaption&gt;
        &lt;h4&gt;Pic 6 : ADC data connectors&lt;/h4&gt;
        
    &lt;/figcaption&gt;
    
&lt;/figure&gt;
&lt;/p&gt;

&lt;p&gt;
&lt;figure &gt;
    
        &lt;img src=&#34;https://www.zeekhuge.me/images/pic7_adc_connection.jpg&#34; width=&#34;1000&#34; /&gt;
    
    
    &lt;figcaption&gt;
        &lt;h4&gt;Pic 7 : Connection with the ADC connectors&lt;/h4&gt;
        
    &lt;/figcaption&gt;
    
&lt;/figure&gt;
&lt;/p&gt;

&lt;p&gt;
&lt;figure &gt;
    
        &lt;img src=&#34;https://www.zeekhuge.me/images/pic8_jst_everything.jpg&#34; width=&#34;1000&#34; /&gt;
    
    
    &lt;figcaption&gt;
        &lt;h4&gt;Pic 8 : Just everything all together&lt;/h4&gt;
        
    &lt;/figcaption&gt;
    
&lt;/figure&gt;
&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>A handful of commands and scripts to get started with BeagleBone Black</title>
      <link>https://www.zeekhuge.me/post/a_handfull_of_commands_and_scripts_to_get_started_with_beagleboneblack/</link>
      <pubDate>Thu, 16 Jun 2016 19:56:39 +0530</pubDate>
      
      <guid>https://www.zeekhuge.me/post/a_handfull_of_commands_and_scripts_to_get_started_with_beagleboneblack/</guid>
      <description>

&lt;p&gt;Here I have compiled a list of commands and some info to get you started with BeagleBone Black. I will keep updating this list of commands as I find something new . I hope that it will save you some time .&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.zeekhuge.me/jokes/worth_time.png&#34; alt=&#34;joke&#34; /&gt;&lt;/p&gt;

&lt;p&gt;picture credits: &lt;a href=&#34;https://xkcd.com&#34;&gt;xkcd.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;All of these commands are to be executed on the BeagleBone black (BBB for short) itself after you login as root, and are expected to work on kernel version 4.4.11+&lt;/p&gt;

&lt;h3 id=&#34;u-content-u:01d25bfd2399ec47b9c04f156786eab8&#34;&gt;&lt;u&gt;Content&lt;/u&gt;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#strt:01d25bfd2399ec47b9c04f156786eab8&#34;&gt;Starters&lt;/a&gt;

&lt;ol&gt;
&lt;li&gt;Environment Variables&lt;/li&gt;
&lt;li&gt;Config-pin utility&lt;/li&gt;
&lt;li&gt;Force rebooting&lt;/li&gt;
&lt;li&gt;Sharing your Ubuntu system&amp;rsquo;s Internet with BBB&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#kdev:01d25bfd2399ec47b9c04f156786eab8&#34;&gt;Kernel Development&lt;/a&gt;

&lt;ol&gt;
&lt;li&gt;Linux Headers&lt;/li&gt;
&lt;li&gt;Install latest kernel&lt;/li&gt;
&lt;li&gt;BBB kernel source&lt;/li&gt;
&lt;li&gt;BBB clone kernel source&lt;/li&gt;
&lt;li&gt;Cross-compiler toolchain&lt;/li&gt;
&lt;li&gt;Particular kernel config file&lt;/li&gt;
&lt;li&gt;Cross compiling the kernel source&lt;/li&gt;
&lt;li&gt;Cross compile a driver&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#wprus:01d25bfd2399ec47b9c04f156786eab8&#34;&gt;Working with PRUs&lt;/a&gt;

&lt;ol&gt;
&lt;li&gt;Fact 1&lt;/li&gt;
&lt;li&gt;To shutdown PRU0&lt;/li&gt;
&lt;li&gt;To shutdown PRU1&lt;/li&gt;
&lt;li&gt;More&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;strt:01d25bfd2399ec47b9c04f156786eab8&#34;&gt;&lt;u&gt;Starters&lt;/u&gt; :&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Environment Variables&lt;/strong&gt; - &lt;em&gt;ssh&lt;/em&gt; into your BBB and append your &lt;em&gt;bashrc&lt;/em&gt; with following lines:
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;nb&#34;&gt;export &lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;PINS&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;/sys/kernel/debug/pinctrl/44e10800.pinmux
&lt;span class=&#34;nb&#34;&gt;export &lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;SLOTS&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;/sys/devices/platform/bone_capemgr/slots
&lt;span class=&#34;nb&#34;&gt;export &lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;FW&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;/lib/firmware
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;Config-pin utility&lt;/strong&gt; - To change the pinmux settings for a pin does not need device tree overlays now (4.4+ kernel), you can simply use &amp;lsquo;config-pin&amp;rsquo; utility. To configure the pin you just need to know its position on the board, so to change mux settings of pin at , for example , P8_46
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;nv&#34;&gt;$ &lt;/span&gt;config-pin -l P8_46
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

The output shows space separated list of available pin-modes and will look like :
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;nv&#34;&gt;$ &lt;/span&gt;default gpio gpio_pu gpio_pd pruout pruin pwm
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

Now to change pinmode, to, for example, pruout
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;nv&#34;&gt;$ &lt;/span&gt;config-pin P8_46 pruout
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

This will configure pin at P8_46 to pru_output mode.
Further status of the pin can be known using &amp;lsquo;config-pin -i&amp;rsquo;, which will give detailed output.
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;nv&#34;&gt;$ &lt;/span&gt;config-pin -i P8_46
Pin name: P8_46
Function &lt;span class=&#34;k&#34;&gt;if &lt;/span&gt;no cape loaded: hdmi
Function &lt;span class=&#34;k&#34;&gt;if &lt;/span&gt;cape loaded: default gpio gpio_pu gpio_pd pruout pruin pwm
Function information: lcd_data1 default gpio2_7 gpio2_7 gpio2_7 pr1_pru1_pru_r30_1 pr1_pru1_pru_r31_1 ehrpwm2B
Cape: cape-universala cape-univ-hdmi
Kernel GPIO id: 71
PRU GPIO id: 103
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;Force rebooting&lt;/strong&gt; -  One of my favorite commands, rebooting your BBB when something goes wrong and it won&amp;rsquo;t reboot the normal way ( Thanks to &lt;a href=&#34;https://github.com/SJLC&#34;&gt;Stephanie&lt;/a&gt; for this).&lt;br /&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;nb&#34;&gt;echo &lt;/span&gt;b &amp;gt;/proc/sysrq-trigger
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;Sharing your Ubuntu system&amp;rsquo;s Internet with BBB&lt;/strong&gt; -  Use the command &lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;nv&#34;&gt;$ &lt;/span&gt;ifconfig 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
 to determine the interface your system is using to connect to BBB (it will be mostly eth0) and to the Internet.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Let the Internet interface and BBB interface be &amp;lt;Internet-interface&amp;gt; and &amp;lt;BBB-interface&amp;gt; respectively. Now on your system, execute following commands as root:&lt;br /&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;nv&#34;&gt;$ &lt;/span&gt;iptables -t nat -A POSTROUTING -o &amp;lt;Internet-interface&amp;gt; -j MASQUERADE
&lt;span class=&#34;nv&#34;&gt;$ &lt;/span&gt;iptables -A FORWARD -i &amp;lt;BBB-interface&amp;gt; -j ACCEPT
&lt;span class=&#34;nv&#34;&gt;$ &lt;/span&gt;sysctl net.ipv4.ip_forward&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

Generally, these commands will look like :
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;nv&#34;&gt;$ &lt;/span&gt;iptables -t nat -A POSTROUTING -o wlan0 -j MASQUERADE
&lt;span class=&#34;nv&#34;&gt;$ &lt;/span&gt;iptables -A FORWARD -i eth0 -j ACCEPT
&lt;span class=&#34;nv&#34;&gt;$ &lt;/span&gt;sysctl net.ipv4.ip_forward&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;On your BBB, execute this command after you login as root :
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;nv&#34;&gt;$ &lt;/span&gt;route add default gw 192.168.7.1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;To automate all this Internet connecting thing, just put all these commands in /etc/rc.local in their respective systems.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Now to test if all this works, use command  &amp;ldquo;ping 8.8.8.8&amp;rdquo; and the output should look like :
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;root@beaglebone:~# ping 8.8.8.8
PING 8.8.8.8 &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;8.8.8.8&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; 56&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;84&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; bytes of data.
64 bytes from 8.8.8.8: &lt;span class=&#34;nv&#34;&gt;icmp_seq&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;1 &lt;span class=&#34;nv&#34;&gt;ttl&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;54 &lt;span class=&#34;nb&#34;&gt;time&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;49.2 ms
64 bytes from 8.8.8.8: &lt;span class=&#34;nv&#34;&gt;icmp_seq&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;2 &lt;span class=&#34;nv&#34;&gt;ttl&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;54 &lt;span class=&#34;nb&#34;&gt;time&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;46.1 ms
64 bytes from 8.8.8.8: &lt;span class=&#34;nv&#34;&gt;icmp_seq&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;3 &lt;span class=&#34;nv&#34;&gt;ttl&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;54 &lt;span class=&#34;nb&#34;&gt;time&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;40.0 ms
64 bytes from 8.8.8.8: &lt;span class=&#34;nv&#34;&gt;icmp_seq&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;4 &lt;span class=&#34;nv&#34;&gt;ttl&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;54 &lt;span class=&#34;nb&#34;&gt;time&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;52.1 ms
^C
--- 8.8.8.8 ping statistics ---
4 packets transmitted, 4 received, 0% packet loss, &lt;span class=&#34;nb&#34;&gt;time &lt;/span&gt;3006ms
rtt min/avg/max/mdev &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; 40.021/46.883/52.108/4.496 ms
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;It will be then useful to add &amp;ldquo;nameserver 8.8.8.8&amp;rdquo; in the first line of your /etc/resolv.conf&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;kdev:01d25bfd2399ec47b9c04f156786eab8&#34;&gt;&lt;u&gt;Kernel Development&lt;/u&gt;&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Linux Headers&lt;/strong&gt; - To install Linux kernel header files for your current Linux version:
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;nv&#34;&gt;$ &lt;/span&gt;apt-get install -y linux-headers-&lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;uname -r&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;Install latest kernel&lt;/strong&gt; - To install a new version of kernel image &lt;u&gt;&lt;strong&gt;&lt;em&gt;for example&lt;/em&gt;&lt;/strong&gt;&lt;/u&gt;: kernel image 4.4.11-ti-r29 ( Thanks to &lt;a href=&#34;https://github.com/sarnold&#34;&gt;Steve Arnold&lt;/a&gt; for these ) :
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;nv&#34;&gt;$ &lt;/span&gt;sudo apt-get update
&lt;span class=&#34;nv&#34;&gt;$ &lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;export &lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;NEW&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;quot;4.4.11-ti-r29&amp;quot;&lt;/span&gt; 
&lt;span class=&#34;nv&#34;&gt;$ &lt;/span&gt;sudo apt-get install -y linux-firmware-image-&lt;span class=&#34;nv&#34;&gt;$NEW&lt;/span&gt; linux-headers-&lt;span class=&#34;nv&#34;&gt;$NEW&lt;/span&gt; linux-image-&lt;span class=&#34;nv&#34;&gt;$NEW&lt;/span&gt; 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;BBB kernel source&lt;/strong&gt; -  To browse the kernel source of a particular version, go onto :&lt;br /&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;https://github.com/RobertCNelson/linux-stable-rcn-ee/tree/&amp;lt;kernel build number&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;u&gt;&lt;strong&gt;&lt;em&gt;for example&lt;/em&gt;&lt;/strong&gt;&lt;/u&gt; if you want to go to the 4.4.11-ti-r29 kernel, the link will be :
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;https://github.com/RobertCNelson/linux-stable-rcn-ee/tree/4.4.11-ti-r29
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;BBB clone kernel source&lt;/strong&gt; - To clone a kernel source ( Thanks to &lt;a href=&#34;https://github.com/mwelling/&#34;&gt;Michael Welling&lt;/a&gt; and &lt;a href=&#34;https://github.com/SJLC&#34;&gt;Stephanie&lt;/a&gt; for help on this )  :
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;nv&#34;&gt;$ &lt;/span&gt;mkdir KERNEL-&amp;lt;kernel build number&amp;gt;
&lt;span class=&#34;nv&#34;&gt;$ &lt;/span&gt;git clone --depth&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;100 -b &amp;lt;kernel build number&amp;gt; https://github.com/RobertCNelson/linux-stable-rcn-ee.git KERNEL-&amp;lt;kernel build number&amp;gt;
&lt;span class=&#34;nv&#34;&gt;$ &lt;/span&gt;touch KERNEL-&amp;lt;kernel build number&amp;gt;/.ignore-&amp;lt;kernel build number&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;u&gt;&lt;strong&gt;&lt;em&gt;for example&lt;/em&gt;&lt;/strong&gt;&lt;/u&gt; if you want to clone the 4.4.11-ti-r29 kernel, the commands will be :
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;nv&#34;&gt;$ &lt;/span&gt;mkdir KERNEL-4.4.11-ti-r29
&lt;span class=&#34;nv&#34;&gt;$ &lt;/span&gt;git clone --depth&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;100 -b 4.4.11-ti-r29 https://github.com/RobertCNelson/linux-stable-rcn-ee.git KERNEL-&amp;lt;kernel build number&amp;gt;
&lt;span class=&#34;nv&#34;&gt;$ &lt;/span&gt;touch KERNEL-4.4.11-ti-r29/.ignore-4.4.11-ti-r29
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;Cross-compiler toolchain&lt;/strong&gt; -  To download the latest version of cross-compiler tool-chain ( command source : &lt;a href=&#34;https://eewiki.net/display/linuxonarm/BeagleBone+Black#BeagleBoneBlack-ARMCrossCompiler:GCC&#34;&gt;eewiki&lt;/a&gt; )
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;nv&#34;&gt;$ &lt;/span&gt;wget -c https://releases.linaro.org/components/toolchain/binaries/5.3-2016.02/arm-linux-gnueabihf/gcc-linaro-5.3-2016.02-x86_64_arm-linux-gnueabihf.tar.xz
&lt;span class=&#34;nv&#34;&gt;$ &lt;/span&gt;tar xf gcc-linaro-5.3-2016.02-x86_64_arm-linux-gnueabihf.tar.xz
&lt;span class=&#34;nv&#34;&gt;$ &lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;export &lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;CC&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;sb&#34;&gt;`&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;pwd&lt;/span&gt;&lt;span class=&#34;sb&#34;&gt;`&lt;/span&gt;/gcc-linaro-5.3-2016.02-x86_64_arm-linux-gnueabihf/bin/arm-linux-gnueabihf-
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;Particular kernel config file&lt;/strong&gt; - To download .config file of a particular kernel build number:
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;nv&#34;&gt;$ &lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;export &lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;NEW&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;quot;&amp;lt;kernel build number&amp;gt;&amp;quot;&lt;/span&gt;
&lt;span class=&#34;nv&#34;&gt;$ &lt;/span&gt;wget -c http://rcn-ee.net/deb/jessie-armhf/v&lt;span class=&#34;nv&#34;&gt;$NEW&lt;/span&gt;/defconfig -O config-&lt;span class=&#34;nv&#34;&gt;$NEW&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;u&gt;&lt;strong&gt;for example&lt;/strong&gt;&lt;/u&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;nv&#34;&gt;$ &lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;export &lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;NEW&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;quot;4.4.11-ti-r29&amp;quot;&lt;/span&gt;
&lt;span class=&#34;nv&#34;&gt;$ &lt;/span&gt;wget -c http://rcn-ee.net/deb/jessie-armhf/v&lt;span class=&#34;nv&#34;&gt;$NEW&lt;/span&gt;/defconfig -O config-&lt;span class=&#34;nv&#34;&gt;$NEW&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;Cross compiling the kernel source&lt;/strong&gt; - To cross compile the source code, cd into the kernel source&amp;rsquo;s root :
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;nv&#34;&gt;$ &lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;export &lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;KERN_V&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;quot;&amp;lt;kernel version&amp;gt;&amp;quot;&lt;/span&gt;
&lt;span class=&#34;nv&#34;&gt;$ &lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;export &lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;BUILD_V&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;quot;&amp;lt;build version&amp;gt;&amp;quot;&lt;/span&gt;
&lt;span class=&#34;nv&#34;&gt;$ &lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;export &lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;CROSS_COMPILE&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;path/to/your/cross/compiler/tool/chain
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;strong&gt;&lt;u&gt;for example&lt;/u&gt;&lt;/strong&gt; for kernel - 4.4.11-ti-r29,
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;nv&#34;&gt;$ &lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;export &lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;KERN_V&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;quot;4.4.11&amp;quot;&lt;/span&gt;
&lt;span class=&#34;nv&#34;&gt;$ &lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;export &lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;BUILD_V&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;quot;-ti-r29&amp;quot;&lt;/span&gt;
&lt;span class=&#34;nv&#34;&gt;$ &lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;export &lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;CROSS_COMPILE&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;../../toolcahin/gcc-linaro-5.3-2016.02-x86_64_arm-linux-gnueabihf/bin/arm-linux-gnueabihf-
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

then after that:
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;nv&#34;&gt;$ &lt;/span&gt;make mrproper &lt;span class=&#34;nv&#34;&gt;ARCH&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;arm &lt;span class=&#34;nv&#34;&gt;LOCALVERSION&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;$BUILD_V&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;CROSS_COMPILE&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;path/to/the/cross/compile/toolchain 
&lt;span class=&#34;nv&#34;&gt;$ &lt;/span&gt;wget -c http://rcn-ee.net/deb/jessie-armhf/v&lt;span class=&#34;nv&#34;&gt;$KERN_V$BUILD_V&lt;/span&gt;/defconfig -O .config
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

now each time you want to build your kernel
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;nv&#34;&gt;$ &lt;/span&gt;make &lt;span class=&#34;nv&#34;&gt;ARCH&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;arm &lt;span class=&#34;nv&#34;&gt;LOCALVERSION&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;$BUILD_V&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;CROSS_COMPILE&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;path/to/the/cross/compile/toolchain 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;Cross compile a driver&lt;/strong&gt; -  To cross compile particular drivers that is present in your kernel source, you will have to go through complete kernel build process at-least once so that it generates that symbol version file, and only then will you be able to load the module. Follow above steps to build the kernel, then to compile one driver
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;nv&#34;&gt;$ &lt;/span&gt;make modules &lt;span class=&#34;nv&#34;&gt;SUB_DIRS&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;path/to/the/driver &lt;span class=&#34;nv&#34;&gt;ARCH&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;arm &lt;span class=&#34;nv&#34;&gt;LOCALVERSION&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;$BUILD_V&lt;/span&gt; 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;strong&gt;&lt;u&gt;for example&lt;/u&gt;&lt;/strong&gt; to compile rpmsg drivers :
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;nv&#34;&gt;$ &lt;/span&gt;make modules &lt;span class=&#34;nv&#34;&gt;SUB_DIRS&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;drivers/rpmsg/ &lt;span class=&#34;nv&#34;&gt;ARCH&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;arm &lt;span class=&#34;nv&#34;&gt;LOCALVERSION&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;$BUILD_V&lt;/span&gt; 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;wprus:01d25bfd2399ec47b9c04f156786eab8&#34;&gt;&lt;u&gt;Working with PRUs&lt;/u&gt;&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Fact 1&lt;/strong&gt; - Rebooting any PRU core (0 or 1) will result in reloading of the firmware that is at /lib/firmware/am335x-pruN-fw (pruN can be pru0 or pru1)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;To shutdown PRU0&lt;/strong&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;nb&#34;&gt;echo&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;quot;4a334000.pru0&amp;quot;&lt;/span&gt; &amp;gt; /sys/bus/platform/drivers/pru-rproc/unbind
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

and to boot it up
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;nb&#34;&gt;echo&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;quot;4a334000.pru0&amp;quot;&lt;/span&gt; &amp;gt; /sys/bus/platform/drivers/pru-rproc/bind
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;To shutdown PRU1&lt;/strong&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;nb&#34;&gt;echo&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;quot;4a338000.pru1&amp;quot;&lt;/span&gt; &amp;gt; /sys/bus/platform/drivers/pru-rproc/unbind
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

and to boot it up
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;nb&#34;&gt;echo&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;quot;4a338000.pru1&amp;quot;&lt;/span&gt; &amp;gt; /sys/bus/platform/drivers/pru-rproc/bind
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;More&lt;/strong&gt; - Some more of them have been described in the &lt;a href=&#34;https://www.zeekhuge.me/post/ptp_docs_commands_and_tools&#34;&gt;2nd post of PTP series&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>Working with PRUs @BeagleBoneBlack : RPMsg framework</title>
      <link>https://www.zeekhuge.me/post/working_with_prus_beagleboneblack_rpmsg/</link>
      <pubDate>Thu, 16 Jun 2016 14:29:03 +0530</pubDate>
      
      <guid>https://www.zeekhuge.me/post/working_with_prus_beagleboneblack_rpmsg/</guid>
      <description>&lt;p&gt;Working on this.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Working with PRUs @BeagleBoneBlack : remoteproc</title>
      <link>https://www.zeekhuge.me/post/working_with_prus_beagleboneblack_remoteproc/</link>
      <pubDate>Thu, 16 Jun 2016 14:28:03 +0530</pubDate>
      
      <guid>https://www.zeekhuge.me/post/working_with_prus_beagleboneblack_remoteproc/</guid>
      <description>&lt;p&gt;Working on this&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Working with PRUs @BeagleBoneBlack : Introduction to PRUs</title>
      <link>https://www.zeekhuge.me/post/working_with_prus_beagleboneblack_introduction_to_prus/</link>
      <pubDate>Thu, 16 Jun 2016 14:27:03 +0530</pubDate>
      
      <guid>https://www.zeekhuge.me/post/working_with_prus_beagleboneblack_introduction_to_prus/</guid>
      <description>

&lt;p&gt;This is the first in a series of posts to explain and provide with some basic examples to work on PRU cores in AM335x. The AM335x SoC can be found on famous embedded board &lt;em&gt;BeagleBone Black&lt;/em&gt;. The post are:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://www.zeekhuge.me/post/working_with_prus_beagleboneblack_introduction_to_prus/&#34;&gt;Introduction to PRUs (this)&lt;/a&gt;
To make you comfortable with the concept of realtime systems with PRUs, and basic introduction to various peripherals in the PRU-ICSS subsystem.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://www.zeekhuge.me/post/working_with_prus_beagleboneblack_remoteproc/&#34;&gt;Remoteproc&lt;/a&gt;
To explain the working of remoteproc Linux driver to manipulate remote processing unit ie PRU for AM335x SoC. This post will provide a logical framework first, and then will dive into the driver&amp;rsquo;s code.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://www.zeekhuge.me/post/working_with_prus_beagleboneblack_rpmsg/&#34;&gt;RPMsg Framework&lt;/a&gt;
Till this post, you will have understanding of how PRUs are booted up and start executing the firmware loaded onto them. This post will further explain the RPMsg way of communication between main processing unit and the PRUs.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;In all these posts, I will be using softwares (kernel images, compilers etc ) that are recommended by &lt;a href=&#34;https://beagleboard.org&#34;&gt;BeagleBoard.org&lt;/a&gt;. This post is just an introduction to PRUs, so is anyway useful. Some of the reference that I have used throughout these posts are :&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;http://www.ti.com/lit/ug/spruh73m/spruh73m.pdf&#34;&gt;TI AM335x Reference manual&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.siue.edu/~gengel/bbbWebStuff/am335xPruReferenceGuide.pdf&#34;&gt;PRU reference Manual&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/beagleboard/am335x_pru_package&#34;&gt;Documents in this repo&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/derekmolloy/boneDeviceTree/tree/master/docs&#34;&gt;Pin configuration details&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;u-prelude-u:f112cc63f5e4b6b33907400366d8b15d&#34;&gt;&lt;u&gt;&lt;strong&gt;Prelude&lt;/strong&gt;&lt;/u&gt;&lt;/h3&gt;

&lt;p&gt;Texas Instruments has this series of processors based on ARM Cortex-A core they call &lt;em&gt;TI&amp;rsquo;s Sitara Processors&lt;/em&gt;. One of these processors that is used in the microcomputer board BeagleBone Black is AM335x . These processors have a very interesting subsystem called &lt;em&gt;PRU-ICSS&lt;/em&gt; as can be seen in top right in the figure below.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.zeekhuge.me/images/22965_am335x_diagram.png&#34; alt=&#34;AM335x&#34; title=&#34;AM335x&#34; /&gt;&lt;/p&gt;

&lt;p&gt;It can be thus said that AM335x has 3 processing cores. Two of them are enclosed in the PRU-ICSS subsystem and are called PRUs, operating at a clock speed of 200 MHz each. The other is the ARM Cortex A8 main processing unit or MPU for short, at 1GHz. This A8 MPU is a high end processor and can have an OS like ubuntu, debian or android running on it. The MPU with all high end processing stuff like caches and pipelines has a lot of limitations regarding to its realtime use. Comes to rescue, the &lt;em&gt;PRU&lt;/em&gt; aka &lt;em&gt;Programmable Realtime Units&lt;/em&gt; that are present on the same SoC.&lt;/p&gt;

&lt;p&gt;At this point, I would like to explain what I mean by &lt;em&gt;&amp;ldquo;realtime use&amp;rdquo;&lt;/em&gt;. Imagine two events &lt;em&gt;&amp;lsquo;crashing of a car&amp;rsquo;&lt;/em&gt; and &lt;em&gt;&amp;lsquo;opening up of the air bags&amp;rsquo;&lt;/em&gt;. The time delay between two events should be very much deterministic as its the matter of someone&amp;rsquo;s life. This is the point where a computer system with deterministic delays, between the input and producing the desired output is needed. In simple terms, realtime systems are used in the arrangements where something critical, in terms of time delays, need to be done. For a realtime system, a developer can easily determine the maximum time delay between a stimulus and its response.&lt;/p&gt;

&lt;p&gt;A general purpose OS&amp;rsquo;s kernel is a combination of some core management softwares along with the softwares to manage and control the hardware. The core part of the kernel has something called scheduler. It schedules various tasks that &lt;em&gt;appear to run&lt;/em&gt; simultaneously on a computer system. Scheduler does this using various algorithms. This makes it almost impossible for a developer to determine the time delay between an input and its output. Even in case of interrupts in general OS, the ISR just notifies the system of interrupt and places the required task in scheduler&amp;rsquo;s queue. Further, availability of hardware features like caches and pipeline system adds to this difficulty in latency determination. There are realtime versions of operating systems too, that allow one to determine the max-latencies, but it has its own cons. The best is to use an independent realtime unit. If you need more justification on why to use a realtime system, see this &lt;a href=&#34;https://www.youtube.com/watch?v=plCYsbmMbmY&#34;&gt;video by Linux foundation&lt;/a&gt; .&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;u-prus-u:f112cc63f5e4b6b33907400366d8b15d&#34;&gt;&lt;u&gt;&lt;strong&gt;PRUs&lt;/strong&gt;&lt;/u&gt;&lt;/h3&gt;

&lt;p&gt;The two PRUs enclosed in the PRU-ICSS subsystem are specially designed for high speed, low latency, realtime processing. PRUs are basically 32 bit RISC processors that can work independent of the MPU. As is shown in the figure below, there are many more peripherals that are enclosed in the PRU-ICSS unit. Integration of all these peripherals in the PRU-ICSS aims to make realtime processing easy, reliable and fast. After all that &lt;em&gt;&amp;ldquo;realtime&amp;rdquo;&lt;/em&gt; stuff above, you may ask, &amp;ldquo;How does the PRUs make realtime thing possible ? after all they are yet another processing core.&amp;rdquo; Well, No, they are not &lt;em&gt;&amp;ldquo;yet another&amp;rdquo;&lt;/em&gt; processing unit, but are special kind of processing unit. They have very limited yet enough number of instructions to program with and almost all of them get executed in single cycle (ie 5 nSec). Each instruction has a perfectly deterministic latency (provided its accessing PRU-ICSS resources, more on this later), has no caches or pipelines and is equipped with enhanced GPIO unit. Using PRUs, you can toggle a GPO at about 50MHz, and believe me, thats a great thing for a SoC having a general purpose OS on it.&lt;br /&gt;
This figure down here may look a bit complex, its rather simple and will be very useful once you understand it.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.zeekhuge.me/images/PRUSS.png&#34; alt=&#34;PRU-ICSS&#34; title=&#34;PRU-ICSS&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;[Note: This post is just to make you comfortable with PRUs for further experimenting and learning, so we are not going to go into deep details of various peripherals in PRU-ICSS. I am just going to give an overview of some of them. We will learn how to use various peripherals in later posts.]&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;So lets go ahead and understand some of the most used peripherals inside PRU-ICSS with reference to the above figure:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;u&gt;&lt;strong&gt;PRU0 and PRU1 cores&lt;/u&gt; :&lt;/strong&gt;
These are the 2 PRU ( Programmable Realtime Unit ) cores we have been talking about. They are 32-bit processors based on RISC design strategy. As a result, they need just a handful of assembly instructions to program them, and most of them, as already stated earlier, execute in one single cycle. The two PRUs are identical in every aspect. Each one them has 8K bytes of program RAM aka instruction RAM or iRAM for short. Apart from the iRam, they have 30, 32-bit general purpose registers in each of them.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;u&gt;&lt;strong&gt;Enhanced GPIO&lt;/u&gt; :&lt;/strong&gt;
You can see a block named &lt;em&gt;Enhanced GPIO&lt;/em&gt; directly connected to each of those PRU cores in the figure. The word &amp;ldquo;&lt;em&gt;Enhanced&lt;/em&gt;&amp;rdquo; is used because of some nifty modes that they have. They are:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Direct Mode : In this mode, all the GPIOs are directly connected to the PRUs internal register. That basically means that whenever the PRU reads the register associated with the GPI, it gets the instantaneous value of the GPI. Same is the case with output, whatever is written to output associated register, appears directly on the GPOs.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Parallel Capture mode (input only): In this mode, one of the GPI is used as an external strobe and other GPIs to capture data. That basically means, the data will be automatically captured by the GPI module when, for example, there is a positive rising edge on its external strobe pin.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;28-bit Shift (input only) : Each PRU has got a shift register that can be used in this mode of operation, to get serial data as input from one of its input pins. The sampling rate can be varied using clock divisors inside the PRUs.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Shift out (output only): This mode is kind of opposite to the 28-bit shift mode, such that, in this mode, the shift register is used to output serial data through one of its GPO.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;u&gt;&lt;strong&gt;OCP ports&lt;/u&gt; :&lt;/strong&gt;
The OCP ports (Open Core Protocol ports) are generally used for communication between various subsystem on the same chip. So as you might have already guessed, these ports are used to communicate with other subsystems, external to the PRU-ICSS, that are present on the SoC. These ports allow &lt;em&gt;PRU&lt;/em&gt; to &lt;em&gt;SoC peripheral (RAM, SPI unit, ADC etc)&lt;/em&gt; communication, or &lt;em&gt;A8 MPU&lt;/em&gt; to &lt;em&gt;PRU-ICSS peripheral (shared RAM, INTC, instruction RAM etc)&lt;/em&gt; communication. The OCP master port is for PRU to external peripheral (via L3 connect bus) communication and OCP slave port is for External peripheral to PRU-ICSS peripheral communication (via L4 connect bus).&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;u&gt;&lt;strong&gt;INTC&lt;/u&gt; :&lt;/strong&gt;
This is an Interrupt controller to manage interrupts from one PRU to other, from PRU to external peripherals or from external peripherals to PRU. At this point you may ask that, &lt;em&gt;for example PRUs are doing some critical job and get interrupted, how does that make it deterministic and reliable for realtime systems ?&lt;/em&gt; Well, interrupts on PRU are not interrupts in classical sense. Occurrence of an interrupt does not actually interrupts the current execution, but it sets an known bit, which needs to be checked by the software on the PRU to perform related task. So for example, if the PRU is doing a critical job, it might detect the interrupt by checking that interrupt-related-bit and choose not to do anything for now, or it might not even check that bit while its doing those critical jobs. There is more to INTC, but thats for later.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;u&gt;&lt;strong&gt;Scratch Pad&lt;/u&gt; :&lt;/strong&gt;
One of the nifty features that PRUs have is the presence of scratch pad. Its a set of 3 banks, with 30, 32 bit registers in each. The most interesting thing about these scratch pads is their broadside interface, which allows swapping of all these 30 registers, between PRU0 and PRU1 or between PRU-n and Bank-m, in just one single cycle. Isn&amp;rsquo;t that cool !
The figure shows this arrangement of registers and scratch pad.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;https://www.zeekhuge.me/images/scratch_pad.png&#34; alt=&#34;Scratch Pad&#34; title=&#34;Scratch_pad&#34; /&gt;&lt;/p&gt;

&lt;p&gt;In addition to all this, PRU-ICSS unit also has MAC (Multiplier - Accumulator unit) for each of the PRUs, a CFG unit that contains various configuration registers and a few more peripherals. We will further see how to use PRUs and various in-PRU-ICSS peripherals to make a realtime system in posts ahead.&lt;/p&gt;

&lt;p&gt;So thats all for this post. Next to it is this post explaining &lt;a href=&#34;https://www.zeekhuge.me/post/working_with_prus_beagleboneblack_remoteproc/&#34;&gt;&lt;em&gt;remoteproc&lt;/em&gt;&lt;/a&gt;, Linux way of working with PRU.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>About Me</title>
      <link>https://www.zeekhuge.me/about/</link>
      <pubDate>Tue, 18 Aug 2015 00:00:00 +0000</pubDate>
      
      <guid>https://www.zeekhuge.me/about/</guid>
      <description>

&lt;p&gt;&lt;link href=&#34;https://fonts.googleapis.com/css?family=Kalam|Pacifico|Ruslan+Display&amp;subset=cyrillic&#34; rel=&#34;stylesheet&#34;&gt;
&lt;center&gt;&lt;/p&gt;

&lt;h1 id=&#34;div-style-font-family-ruslan-display-cursive-about-me-div:6083a88ee3411b0d17ce02d738f69d47&#34;&gt;&lt;div style=&#34;font-family: &#39;Ruslan Display&#39;, cursive;&#34;&gt;About me&lt;/div&gt;&lt;/h1&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;center:6083a88ee3411b0d17ce02d738f69d47&#34;&gt;&lt;/center&gt;&lt;/h2&gt;

&lt;p&gt;&lt;div style=&#34;font-family: &#39;Kalam&#39;, cursive;&#34;&gt;
&lt;font size=&#34;5&#34;&gt;Hi ! I am &lt;strong&gt;Zubeen Tolani&lt;/strong&gt;, AKA &lt;strong&gt;ZeekHuge&lt;/strong&gt;, an undergraduate student at the department of &lt;strong&gt;Electronics and Communication Engineering&lt;/strong&gt;.&lt;/font&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;/div&gt;
&lt;br&gt;
&lt;font size=&#34;5&#34;&gt;&lt;u&gt;&lt;strong&gt;Tl;Dr version:&lt;/strong&gt;&lt;/u&gt;&lt;/font&gt;&lt;/p&gt;

&lt;p&gt;&lt;div style=&#34;font-family: &#39;Kalam&#39;, cursive;&#34;&gt;&lt;/p&gt;

&lt;p&gt;&lt;br&gt;
* &lt;font size=&#34;4&#34;&gt;I am stubborn and quite logical in my arguments, so think twice before arguing me.&lt;/font&gt;
&lt;br&gt;&lt;br&gt;
* &lt;font size=&#34;4&#34;&gt;A die hard Michael Jackson fan, and love all three, his dance, his music and him.&lt;/font&gt;
&lt;br&gt;&lt;br&gt;
* &lt;font size=&#34;4&#34;&gt;I love to read and discuss about &lt;strong&gt;Physics&lt;/strong&gt;, &lt;strong&gt;Existence of God&lt;/strong&gt;, &lt;strong&gt;Mathematics&lt;/strong&gt; and &lt;strong&gt;The true nature of this World&lt;/strong&gt;. So always assume that I am free for such discussions ( except when I am busy ).&lt;/font&gt;
&lt;br&gt;&lt;br&gt;
* &lt;font size=&#34;4&#34;&gt;Knowing that I am wrong, I still believe that : &lt;/font&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;font size=&#34;4&#34;&gt;Anything can be done in a time period of 3 months&lt;/font&gt;&lt;/li&gt;
&lt;li&gt;&lt;font size=&#34;4&#34;&gt;An engineer can find solution to any problem in this world&lt;/font&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br&gt;&lt;br&gt;
* &lt;font size=&#34;4&#34;&gt;I am a &lt;u&gt;&lt;strong&gt;true VIM user&lt;/strong&gt;&lt;/u&gt;, of course not like this one.&lt;/font&gt;
&lt;/font&gt;
&lt;/div&gt;
&lt;center&gt;&lt;blockquote class=&#34;imgur-embed-pub&#34; lang=&#34;en&#34; data-id=&#34;v3uSDVk&#34;&gt;&lt;a href=&#34;//imgur.com/v3uSDVk&#34;&gt;Loyal Vim User !&lt;/a&gt;&lt;/blockquote&gt;&lt;script async src=&#34;//s.imgur.com/min/embed.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/center&gt;
&lt;br&gt;&lt;br&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;font size=&#34;5&#34;&gt;&lt;u&gt;&lt;strong&gt;The long version:&lt;/strong&gt;&lt;/u&gt;&lt;/font&gt;
&lt;div style=&#34;font-family: &#39;Kalam&#39;, cursive;&#34;&gt;
&lt;br&gt;
&lt;font size=&#34;5&#34;&gt;&lt;u&gt;Me:&lt;/u&gt;&lt;/font&gt;&lt;p&gt;&lt;/p&gt;

&lt;p&gt;&lt;font size=&#34;4&#34;&gt;So basically, I love to solve problems that involve use of technology, and can have a good enough impact on things. As an example. Most of my work has been in embedded systems, digital electronics and software development. I know quite a few computer programming languages but I am most proficient in C and C++.&lt;/p&gt;&lt;p&gt;My real interest in programming and electronics came out in last 3-4 years. And during that time I have participated in inter college robotics competition, College level competitive programming contests, worked on some sponsored projects (one by Texas Instruments) and participated in Google Summer of Code 2016.&lt;/p&gt;&lt;p&gt; I have worked on embedded systems and have made a few simple robots like :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Wirelessly Gesture controlled robot.&lt;/li&gt;
&lt;li&gt;Robot for rough terrains&lt;/li&gt;
&lt;li&gt;Autonomous to place blocks at right position&lt;/li&gt;
&lt;li&gt;and ofc, line followers.
&lt;/p&gt;&lt;/font&gt;
&lt;br&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;font size=&#34;5&#34;&gt;&lt;u&gt;Whats &amp;lsquo;ZeekHuge&amp;rsquo;:&lt;/u&gt;&lt;/font&gt;&lt;p&gt;
&lt;font size=&#34;4&#34;&gt;&lt;p&gt;Yeah, most of you might be thinking that my alias &amp;lsquo;ZeekHuge&amp;rsquo; is a meaningless word, and believe me, it really IS meaningless. I was in my 7th-8th Std. and use to watch &amp;ldquo;The Suite Life of Zack &amp;amp; Cody&amp;rdquo; and one day an idea popped up in my mind = &amp;ldquo;Hey ! &amp;lsquo;Zeek&amp;rsquo; is such a good name and I can keep it as my secret name !&amp;rdquo; And then, even I don&amp;rsquo;t know how that &lt;em&gt;&amp;lsquo;Huge&amp;rsquo;&lt;/em&gt; thing got attached with it&amp;hellip; but anyway .. it looks cool ! Isn&amp;rsquo;t it ? &lt;/p&gt;
&lt;/font&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;&lt;font size=&#34;5&#34;&gt;&lt;u&gt;Whats the VIM thingy ?:&lt;/u&gt;&lt;/font&gt;&lt;p&gt;
&lt;font size=&#34;4&#34;&gt;&lt;p&gt;What ? You want to read this section too ? You don&amp;rsquo;t know what VIM is ? Its the only true editor that&amp;rsquo;s left around now &amp;hellip;. that&amp;rsquo;s it &amp;hellip; and I love it :D ! Really ! I started using Vim about 5 months ago, when one of my mentors recommended it to me and then .. I have been using it for everything &amp;hellip; and getting taste of its power and yes, learning new things about it everyday !! In fact, I remapped some of navigation keys-bindings of &lt;strong&gt;&amp;lsquo;tmux&amp;rsquo;&lt;/strong&gt; so as to match the key-bindings of &lt;strong&gt;VIM&lt;/strong&gt;. I would just say, in capitals - &lt;strong&gt;&amp;ldquo;vim is really great!&amp;rdquo;&lt;/strong&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;br&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;center&gt;&lt;/p&gt;

&lt;h5 id=&#34;want-to-hire-me-https-goo-gl-st3jnp-why-i-brag-about-using-vim-images-vim-power-png-talk-is-cheap-show-me-the-code-https-github-com-zeekhuge:6083a88ee3411b0d17ce02d738f69d47&#34;&gt;|| &lt;a href=&#34;https://goo.gl/St3JNp&#34;&gt;Want to hire me ?&lt;/a&gt; || &lt;a href=&#34;https://www.zeekhuge.me/images/vim_power.png&#34;&gt;Why I brag about using vim ?&lt;/a&gt; || &lt;a href=&#34;https://github.com/ZeekHuge&#34;&gt;Talk is cheap ! Show me the code !&lt;/a&gt; ||&lt;/h5&gt;

&lt;p&gt;&lt;/center&gt;&lt;/p&gt;

&lt;hr /&gt;
</description>
    </item>
    
  </channel>
</rss>