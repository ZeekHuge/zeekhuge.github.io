<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>ZeekHuge</title>
    <link>https://zeekhuge.github.io/</link>
    <description>Recent content on ZeekHuge</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 10 Jul 2016 03:00:17 +0530</lastBuildDate>
    <atom:link href="https://zeekhuge.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>SomeShots</title>
      <link>https://zeekhuge.github.io/post/some_shots/</link>
      <pubDate>Sun, 10 Jul 2016 03:00:17 +0530</pubDate>
      
      <guid>https://zeekhuge.github.io/post/some_shots/</guid>
      <description>

&lt;p&gt;BeagleScope project can be found &lt;a href=&#34;https://github.com/ZeekHuge/BeagleScope&#34;&gt;here&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;some-shots:0c26a2495997b81bc3012ac9e5454c14&#34;&gt;Some Shots&lt;/h3&gt;

&lt;p&gt;These are are some clicks of the hardware setup that I am going to use for the beaglescope project.&lt;/p&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;https://zeekhuge.github.io/images/pic1_bbb_power.jpg&#34; width=&#34;1000&#34; /&gt;
    
    
    &lt;figcaption&gt;
        &lt;h4&gt;Pic 1 : BBB power supply&lt;/h4&gt;
        
    &lt;/figcaption&gt;
    
&lt;/figure&gt;



&lt;figure &gt;
    
        &lt;img src=&#34;https://zeekhuge.github.io/images/pic2_adc_power_cnnct.jpg&#34; width=&#34;1000&#34; /&gt;
    
    
    &lt;figcaption&gt;
        &lt;h4&gt;Pic 2 : ADC power connections&lt;/h4&gt;
        
    &lt;/figcaption&gt;
    
&lt;/figure&gt;


&lt;p&gt;
&lt;figure &gt;
    
        &lt;img src=&#34;https://zeekhuge.github.io/images/pic3_adc_power_src.jpg&#34; width=&#34;1000&#34; /&gt;
    
    
    &lt;figcaption&gt;
        &lt;h4&gt;Pic 3 : ADC power source &lt;/h4&gt;
        
    &lt;/figcaption&gt;
    
&lt;/figure&gt;
&lt;/p&gt;

&lt;p&gt;
&lt;figure &gt;
    
        &lt;img src=&#34;https://zeekhuge.github.io/images/pic4_smthing_like_cape.jpg&#34; width=&#34;1000&#34; /&gt;
    
    
    &lt;figcaption&gt;
        &lt;h4&gt;Pic 4 : Something like a cape &lt;/h4&gt;
        
    &lt;/figcaption&gt;
    
&lt;/figure&gt;
&lt;/p&gt;

&lt;p&gt;
&lt;figure &gt;
    
        &lt;img src=&#34;https://zeekhuge.github.io/images/pic5_overlay_bbb.jpg&#34; width=&#34;1000&#34; /&gt;
    
    
    &lt;figcaption&gt;
        &lt;h4&gt;Pic 5 : The connections of &amp;#39;something like a cape&amp;#39;&lt;/h4&gt;
        
    &lt;/figcaption&gt;
    
&lt;/figure&gt;
&lt;/p&gt;

&lt;p&gt;
&lt;figure &gt;
    
        &lt;img src=&#34;https://zeekhuge.github.io/images/pic6_adc_connectors.jpg&#34; width=&#34;1000&#34; /&gt;
    
    
    &lt;figcaption&gt;
        &lt;h4&gt;Pic 6 : ADC data connectors&lt;/h4&gt;
        
    &lt;/figcaption&gt;
    
&lt;/figure&gt;
&lt;/p&gt;

&lt;p&gt;
&lt;figure &gt;
    
        &lt;img src=&#34;https://zeekhuge.github.io/images/pic7_adc_connection.jpg&#34; width=&#34;1000&#34; /&gt;
    
    
    &lt;figcaption&gt;
        &lt;h4&gt;Pic 7 : Connection with the ADC connectors&lt;/h4&gt;
        
    &lt;/figcaption&gt;
    
&lt;/figure&gt;
&lt;/p&gt;

&lt;p&gt;
&lt;figure &gt;
    
        &lt;img src=&#34;https://zeekhuge.github.io/images/pic8_jst_everything.jpg&#34; width=&#34;1000&#34; /&gt;
    
    
    &lt;figcaption&gt;
        &lt;h4&gt;Pic 8 : Just everything all together&lt;/h4&gt;
        
    &lt;/figcaption&gt;
    
&lt;/figure&gt;
&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>A handful of commands and scripts to get started with BeagleBone Black</title>
      <link>https://zeekhuge.github.io/post/a_handfull_of_commands_and_scripts_to_get_started_with_beagleboneblack/</link>
      <pubDate>Thu, 16 Jun 2016 19:56:39 +0530</pubDate>
      
      <guid>https://zeekhuge.github.io/post/a_handfull_of_commands_and_scripts_to_get_started_with_beagleboneblack/</guid>
      <description>

&lt;p&gt;Here I have compiled a list of commands and some info to get you started with BeagleBone Black. I will keep updating this list of commands as I find something new .&lt;/p&gt;

&lt;p&gt;All of these commands are to be executed on the BeagleBone black (BBB for short) itself after you login as root, and are expected to work on kernel version 4.4.11+&lt;/p&gt;

&lt;h3 id=&#34;starters:01d25bfd2399ec47b9c04f156786eab8&#34;&gt;&lt;strong&gt;&lt;u&gt;&lt;a href=&#34;#starters:01d25bfd2399ec47b9c04f156786eab8&#34;&gt;Starters&lt;/a&gt;&lt;/u&gt; :&lt;/strong&gt;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;em&gt;ssh&lt;/em&gt; into your BBB and append your &lt;em&gt;bashrc&lt;/em&gt; with following lines:
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;nb&#34;&gt;export &lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;PINS&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;/sys/kernel/debug/pinctrl/44e10800.pinmux
&lt;span class=&#34;nb&#34;&gt;export &lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;SLOTS&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;/sys/devices/platform/bone_capemgr/slots
&lt;span class=&#34;nb&#34;&gt;export &lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;FW&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;/lib/firmware
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;To change the pinmux settings for a pin does not need device tree overlays now (4.4+ kernel), you can simply use &amp;lsquo;config-pin&amp;rsquo; utility. To configure the pin you just need to know its position on the board, so to change mux settings of pin at , for example , P8_46
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;nv&#34;&gt;$ &lt;/span&gt;config-pin -l P8_46
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

The output shows space separated list of available pin-modes and will look like :
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;nv&#34;&gt;$ &lt;/span&gt;default gpio gpio_pu gpio_pd pruout pruin pwm
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

Now to change pinmode, to, for example, pruout
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;nv&#34;&gt;$ &lt;/span&gt;config-pin P8_46 pruout
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

This will configure pin at P8_46 to pru_output mode.
Further status of the pin can be known using &amp;lsquo;config-pin -i&amp;rsquo;, which will give detailed output.
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;nv&#34;&gt;$ &lt;/span&gt;config-pin -i P8_46
Pin name: P8_46
Function &lt;span class=&#34;k&#34;&gt;if &lt;/span&gt;no cape loaded: hdmi
Function &lt;span class=&#34;k&#34;&gt;if &lt;/span&gt;cape loaded: default gpio gpio_pu gpio_pd pruout pruin pwm
Function information: lcd_data1 default gpio2_7 gpio2_7 gpio2_7 pr1_pru1_pru_r30_1 pr1_pru1_pru_r31_1 ehrpwm2B
Cape: cape-universala cape-univ-hdmi
Kernel GPIO id: 71
PRU GPIO id: 103
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;One of my favorite commands, rebooting your BBB when something goes wrong and it won&amp;rsquo;t reboot the normal way ( Thanks to &lt;a href=&#34;https://github.com/SJLC&#34;&gt;Stephanie&lt;/a&gt; for this).&lt;br /&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;nb&#34;&gt;echo &lt;/span&gt;b &amp;gt;/proc/sysrq-trigger
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Sharing your Ubuntu system&amp;rsquo;s Internet with BBB. Use the command &lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;nv&#34;&gt;$ &lt;/span&gt;ifconfig 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
 to determine the interface your system is using to connect to BBB (it will be mostly eth0) and to the Internet.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Let the Internet interface and BBB interface be &amp;lt;Internet-interface&amp;gt; and &amp;lt;BBB-interface&amp;gt; respectively. Now on your system, execute following commands as root:&lt;br /&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;nv&#34;&gt;$ &lt;/span&gt;iptables -t nat -A POSTROUTING -o &amp;lt;Internet-interface&amp;gt; -j MASQUERADE
&lt;span class=&#34;nv&#34;&gt;$ &lt;/span&gt;iptables -A FORWARD -i &amp;lt;BBB-interface&amp;gt; -j ACCEPT
&lt;span class=&#34;nv&#34;&gt;$ &lt;/span&gt;sysctl net.ipv4.ip_forward&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

Generally, these commands will look like :
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;nv&#34;&gt;$ &lt;/span&gt;iptables -t nat -A POSTROUTING -o wlan0 -j MASQUERADE
&lt;span class=&#34;nv&#34;&gt;$ &lt;/span&gt;iptables -A FORWARD -i etch1 -j ACCEPT
&lt;span class=&#34;nv&#34;&gt;$ &lt;/span&gt;sysctl net.ipv4.ip_forward&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;On your BBB, execute this command after you login as root :
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;nv&#34;&gt;$ &lt;/span&gt;route add default gw 192.168.7.1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;To automate all this Internet connecting thing, just put all these commands in /etc/rc.local in their respective systems.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;k_dev:01d25bfd2399ec47b9c04f156786eab8&#34;&gt;&lt;strong&gt;&lt;u&gt;&lt;a href=&#34;#k_dev:01d25bfd2399ec47b9c04f156786eab8&#34;&gt;Kernel Development&lt;/a&gt;&lt;/u&gt; :&lt;/strong&gt;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;To install Linux kernel header files for your current Linux version:
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;nv&#34;&gt;$ &lt;/span&gt;apt-get install -y linux-headers-&lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;uname -r&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;To install a new version of kernel image &lt;u&gt;&lt;strong&gt;&lt;em&gt;for example&lt;/em&gt;&lt;/strong&gt;&lt;/u&gt;: kernel image 4.4.11-ti-r29 ( Thanks to &lt;a href=&#34;https://github.com/sarnold&#34;&gt;Steve Arnold&lt;/a&gt; for these ) :
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;nv&#34;&gt;$ &lt;/span&gt;sudo apt-get update
&lt;span class=&#34;nv&#34;&gt;$ &lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;export &lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;NEW&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;quot;4.4.11-ti-r29&amp;quot;&lt;/span&gt; 
&lt;span class=&#34;nv&#34;&gt;$ &lt;/span&gt;sudo apt-get install -y linux-firmware-image-&lt;span class=&#34;nv&#34;&gt;$NEW&lt;/span&gt; linux-headers-&lt;span class=&#34;nv&#34;&gt;$NEW&lt;/span&gt; linux-image-&lt;span class=&#34;nv&#34;&gt;$NEW&lt;/span&gt; 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;To browse the kernel source of a particular version, go onto :&lt;br /&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;https://github.com/RobertCNelson/linux-stable-rcn-ee/tree/&amp;lt;kernel build number&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;u&gt;&lt;strong&gt;&lt;em&gt;for example&lt;/em&gt;&lt;/strong&gt;&lt;/u&gt; if you want to go to the 4.4.11-ti-r29 kernel, the link will be :
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;https://github.com/RobertCNelson/linux-stable-rcn-ee/tree/4.4.11-ti-r29
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;To download a compressed kernel source, go onto:
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;https://github.com/RobertCNelson/linux-stable-rcn-ee/releases/tag/&amp;lt;kernel build number&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;u&gt;&lt;strong&gt;&lt;em&gt;for example&lt;/em&gt;&lt;/strong&gt;&lt;/u&gt; if you want to go to download 4.4.11-ti-r29 kernel, the link will be :
    &lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;https://github.com/RobertCNelson/linux-stable-rcn-ee/releases/tag/4.4.11-ti-r29
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;To clone a kernel source ( Thanks to &lt;a href=&#34;https://github.com/mwelling/&#34;&gt;Michael Welling&lt;/a&gt; and &lt;a href=&#34;https://github.com/SJLC&#34;&gt;Stephanie&lt;/a&gt; for help on this )  :
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;nv&#34;&gt;$ &lt;/span&gt;mkdir KERNEL-&amp;lt;kernel build number&amp;gt;
&lt;span class=&#34;nv&#34;&gt;$ &lt;/span&gt;git clone --depth&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;100 -b &amp;lt;kernel build number&amp;gt; https://github.com/RobertCNelson/linux-stable-rcn-ee.git KERNEL-&amp;lt;kernel build number&amp;gt;
&lt;span class=&#34;nv&#34;&gt;$ &lt;/span&gt;touch KERNEL-&amp;lt;kernel build number&amp;gt;/.ignore-&amp;lt;kernel build number&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;u&gt;&lt;strong&gt;&lt;em&gt;for example&lt;/em&gt;&lt;/strong&gt;&lt;/u&gt; if you want to clone the 4.4.11-ti-r29 kernel, the commands will be :
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;nv&#34;&gt;$ &lt;/span&gt;mkdir KERNEL-4.4.11-ti-r29
&lt;span class=&#34;nv&#34;&gt;$ &lt;/span&gt;git clone --depth&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;100 -b 4.4.11-ti-r29 https://github.com/RobertCNelson/linux-stable-rcn-ee.git KERNEL-&amp;lt;kernel build number&amp;gt;
&lt;span class=&#34;nv&#34;&gt;$ &lt;/span&gt;touch KERNEL-4.4.11-ti-r29/.ignore-4.4.11-ti-r29
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;To download the latest version of cross-compiler tool-chain ( command source : &lt;a href=&#34;https://eewiki.net/display/linuxonarm/BeagleBone+Black#BeagleBoneBlack-ARMCrossCompiler:GCC&#34;&gt;eewiki&lt;/a&gt; )
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;nv&#34;&gt;$ &lt;/span&gt;wget -c https://releases.linaro.org/components/toolchain/binaries/5.3-2016.02/arm-linux-gnueabihf/gcc-linaro-5.3-2016.02-x86_64_arm-linux-gnueabihf.tar.xz
&lt;span class=&#34;nv&#34;&gt;$ &lt;/span&gt;tar xf gcc-linaro-5.3-2016.02-x86_64_arm-linux-gnueabihf.tar.xz
&lt;span class=&#34;nv&#34;&gt;$ &lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;export &lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;CC&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;sb&#34;&gt;`&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;pwd&lt;/span&gt;&lt;span class=&#34;sb&#34;&gt;`&lt;/span&gt;/gcc-linaro-5.3-2016.02-x86_64_arm-linux-gnueabihf/bin/arm-linux-gnueabihf-
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;To download .config file of a particular kernel build number:
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;nv&#34;&gt;$ &lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;export &lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;NEW&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;quot;&amp;lt;kernel build number&amp;gt;&amp;quot;&lt;/span&gt;
&lt;span class=&#34;nv&#34;&gt;$ &lt;/span&gt;wget -c http://rcn-ee.net/deb/jessie-armhf/v&lt;span class=&#34;nv&#34;&gt;$NEW&lt;/span&gt;/defconfig -O config-&lt;span class=&#34;nv&#34;&gt;$NEW&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;u&gt;&lt;strong&gt;for example&lt;/strong&gt;&lt;/u&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;nv&#34;&gt;$ &lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;export &lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;NEW&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;quot;4.4.11-ti-r29&amp;quot;&lt;/span&gt;
&lt;span class=&#34;nv&#34;&gt;$ &lt;/span&gt;wget -c http://rcn-ee.net/deb/jessie-armhf/v&lt;span class=&#34;nv&#34;&gt;$NEW&lt;/span&gt;/defconfig -O config-&lt;span class=&#34;nv&#34;&gt;$NEW&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;To cross compile the source code, cd into the kernel source&amp;rsquo;s root :
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;nv&#34;&gt;$ &lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;export &lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;KERN_V&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;quot;&amp;lt;kernel version&amp;gt;&amp;quot;&lt;/span&gt;
&lt;span class=&#34;nv&#34;&gt;$ &lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;export &lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;BUILD_V&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;quot;&amp;lt;build version&amp;gt;&amp;quot;&lt;/span&gt;
&lt;span class=&#34;nv&#34;&gt;$ &lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;export &lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;CROSS_COMPILE&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;path/to/your/cross/compiler/tool/chain
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;strong&gt;&lt;u&gt;for example&lt;/u&gt;&lt;/strong&gt; for kernel - 4.4.11-ti-r29,
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;nv&#34;&gt;$ &lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;export &lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;KERN_V&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;quot;4.4.11&amp;quot;&lt;/span&gt;
&lt;span class=&#34;nv&#34;&gt;$ &lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;export &lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;BUILD_V&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;quot;-ti-r29&amp;quot;&lt;/span&gt;
&lt;span class=&#34;nv&#34;&gt;$ &lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;export &lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;CROSS_COMPILE&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;../../toolcahin/gcc-linaro-5.3-2016.02-x86_64_arm-linux-gnueabihf/bin/arm-linux-gnueabihf-
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

then after that:
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;nv&#34;&gt;$ &lt;/span&gt;make mrproper &lt;span class=&#34;nv&#34;&gt;ARCH&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;arm &lt;span class=&#34;nv&#34;&gt;LOCALVERSION&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;$BUILD_V&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;CROSS_COMPILE&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;path/to/the/cross/compile/toolchain 
&lt;span class=&#34;nv&#34;&gt;$ &lt;/span&gt;wget -c http://rcn-ee.net/deb/jessie-armhf/v&lt;span class=&#34;nv&#34;&gt;$KERN_V$BUILD_V&lt;/span&gt;/defconfig -O .config
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

now each time you want to build your kernel
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;nv&#34;&gt;$ &lt;/span&gt;make &lt;span class=&#34;nv&#34;&gt;ARCH&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;arm &lt;span class=&#34;nv&#34;&gt;LOCALVERSION&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;$BUILD_V&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;CROSS_COMPILE&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;path/to/the/cross/compile/toolchain 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;To cross compile particular drivers, you will have to go through complete kernel build process at-least once so that it generates that symbol version file, and only then will you be able to load the module. Follow above steps to build the kernel, then to compile one driver
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;nv&#34;&gt;$ &lt;/span&gt;make modules &lt;span class=&#34;nv&#34;&gt;SUB_DIRS&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;path/to/the/driver &lt;span class=&#34;nv&#34;&gt;ARCH&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;arm &lt;span class=&#34;nv&#34;&gt;LOCALVERSION&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;$BUILD_V&lt;/span&gt; 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;strong&gt;&lt;u&gt;for example&lt;/u&gt;&lt;/strong&gt; to compile rpmsg drivers :
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;nv&#34;&gt;$ &lt;/span&gt;make modules &lt;span class=&#34;nv&#34;&gt;SUB_DIRS&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;drivers/rpmsg/ &lt;span class=&#34;nv&#34;&gt;ARCH&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;arm &lt;span class=&#34;nv&#34;&gt;LOCALVERSION&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;$BUILD_V&lt;/span&gt; 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;working_with_prus:01d25bfd2399ec47b9c04f156786eab8&#34;&gt;&lt;strong&gt;&lt;u&gt;&lt;a href=&#34;#working_with_prus:01d25bfd2399ec47b9c04f156786eab8&#34;&gt;Working with PRUs&lt;/a&gt;&lt;/u&gt; :&lt;/strong&gt;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Rebooting any PRU core (0 or 1) will result in reloading of the firmware that is at /lib/firmware/am335x-pruN-fw (pruN can be pru0 or pru1)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;To shutdown PRU0
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;nb&#34;&gt;echo&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;quot;4a334000.pru0&amp;quot;&lt;/span&gt; &amp;gt; /sys/bus/platform/drivers/pru-rproc/unbind
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

and to boot it up
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;nb&#34;&gt;echo&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;quot;4a334000.pru0&amp;quot;&lt;/span&gt; &amp;gt; /sys/bus/platform/drivers/pru-rproc/bind
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;To shutdown PRU1
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;nb&#34;&gt;echo&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;quot;4a338000.pru1&amp;quot;&lt;/span&gt; &amp;gt; /sys/bus/platform/drivers/pru-rproc/unbind
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

and to boot it up
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;nb&#34;&gt;echo&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;quot;4a338000.pru1&amp;quot;&lt;/span&gt; &amp;gt; /sys/bus/platform/drivers/pru-rproc/bind
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Working with PRUs @BeagleBoneBlack : RPMsg framework</title>
      <link>https://zeekhuge.github.io/post/working_with_prus_beagleboneblack_rpmsg/</link>
      <pubDate>Thu, 16 Jun 2016 14:29:03 +0530</pubDate>
      
      <guid>https://zeekhuge.github.io/post/working_with_prus_beagleboneblack_rpmsg/</guid>
      <description>&lt;p&gt;Working on this.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Working with PRUs @BeagleBoneBlack : remoteproc</title>
      <link>https://zeekhuge.github.io/post/working_with_prus_beagleboneblack_remoteproc/</link>
      <pubDate>Thu, 16 Jun 2016 14:28:03 +0530</pubDate>
      
      <guid>https://zeekhuge.github.io/post/working_with_prus_beagleboneblack_remoteproc/</guid>
      <description>&lt;p&gt;Working on this&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Working with PRUs @BeagleBoneBlack : Introduction to PRUs</title>
      <link>https://zeekhuge.github.io/post/working_with_prus_beagleboneblack_introduction_to_prus/</link>
      <pubDate>Thu, 16 Jun 2016 14:27:03 +0530</pubDate>
      
      <guid>https://zeekhuge.github.io/post/working_with_prus_beagleboneblack_introduction_to_prus/</guid>
      <description>

&lt;p&gt;This is the first in a series of posts to explain and provide with some basic examples to work on PRU cores in AM335x. The AM335x SoC can be found on famous embedded board &lt;em&gt;BeagleBone Black&lt;/em&gt;. The post are:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://zeekhuge.github.io/post/working_with_prus_beagleboneblack_introduction_to_prus/&#34;&gt;Introduction to PRUs (this)&lt;/a&gt;
To make you comfortable with the concept of realtime systems with PRUs, and basic introduction to various peripherals in the PRU-ICSS subsystem.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://zeekhuge.github.io/post/working_with_prus_beagleboneblack_remoteproc/&#34;&gt;Remoteproc&lt;/a&gt;
To explain the working of remoteproc Linux driver to manipulate remote processing unit ie PRU for AM335x SoC. This post will provide a logical framework first, and then will dive into the driver&amp;rsquo;s code.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://zeekhuge.github.io/post/working_with_prus_beagleboneblack_rpmsg/&#34;&gt;RPMsg Framework&lt;/a&gt;
Till this post, you will have understanding of how PRUs are booted up and start executing the firmware loaded onto them. This post will further explain the RPMsg way of communication between main processing unit and the PRUs.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;In all these posts, I will be using softwares (kernel images, compilers etc ) that are recommended by &lt;a href=&#34;https://beagleboard.org&#34;&gt;BeagleBoard.org&lt;/a&gt;. This post is just an introduction to PRUs, so is anyway useful. Some of the reference that I have used throughout these posts are :&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;http://www.ti.com/lit/ug/spruh73m/spruh73m.pdf&#34;&gt;TI AM335x Reference manual&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.siue.edu/~gengel/bbbWebStuff/am335xPruReferenceGuide.pdf&#34;&gt;PRU reference Manual&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/beagleboard/am335x_pru_package&#34;&gt;Documents in this repo&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/derekmolloy/boneDeviceTree/tree/master/docs&#34;&gt;Pin configuration details&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;u-prelude-u:f112cc63f5e4b6b33907400366d8b15d&#34;&gt;&lt;u&gt;&lt;strong&gt;Prelude&lt;/strong&gt;&lt;/u&gt;&lt;/h3&gt;

&lt;p&gt;Texas Instruments has this series of processors based on ARM Cortex-A core they call &lt;em&gt;TI&amp;rsquo;s Sitara Processors&lt;/em&gt;. One of these processors that is used in the microcomputer board BeagleBone Black is AM335x . These processors have a very interesting subsystem called &lt;em&gt;PRU-ICSS&lt;/em&gt; as can be seen in top right in the figure below.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://zeekhuge.github.io/images/22965_am335x_diagram.png&#34; alt=&#34;AM335x&#34; title=&#34;AM335x&#34; /&gt;&lt;/p&gt;

&lt;p&gt;It can be thus said that AM335x has 3 processing cores. Two of them are enclosed in the PRU-ICSS subsystem and are called PRUs, operating at a clock speed of 200 MHz each. The other is the ARM Cortex A8 main processing unit or MPU for short, at 1GHz. This A8 MPU is a high end processor and can have an OS like ubuntu, debian or android running on it. The MPU with all high end processing stuff like caches and pipelines has a lot of limitations regarding to its realtime use. Comes to rescue, the &lt;em&gt;PRU&lt;/em&gt; aka &lt;em&gt;Programmable Realtime Units&lt;/em&gt; that are present on the same SoC.&lt;/p&gt;

&lt;p&gt;At this point, I would like to explain what I mean by &lt;em&gt;&amp;ldquo;realtime use&amp;rdquo;&lt;/em&gt;. Imagine two events &lt;em&gt;&amp;lsquo;crashing of a car&amp;rsquo;&lt;/em&gt; and &lt;em&gt;&amp;lsquo;opening up of the air bags&amp;rsquo;&lt;/em&gt;. The time delay between two events should be very much deterministic as its the matter of someone&amp;rsquo;s life. This is the point where a computer system with deterministic delays, between the input and producing the desired output is needed. In simple terms, realtime systems are used in the arrangements where something critical, in terms of time delays, need to be done. For a realtime system, a developer can easily determine the maximum time delay between a stimulus and its response.&lt;/p&gt;

&lt;p&gt;A general purpose OS&amp;rsquo;s kernel is a combination of some core management softwares along with the softwares to manage and control the hardware. The core part of the kernel has something called scheduler. It schedules various tasks that &lt;em&gt;appear to run&lt;/em&gt; simultaneously on a computer system. Scheduler does this using various algorithms. This makes it almost impossible for a developer to determine the time delay between an input and its output. Even in case of interrupts in general OS, the ISR just notifies the system of interrupt and places the required task in scheduler&amp;rsquo;s queue. Further, availability of hardware features like caches and pipeline system adds to this difficulty in latency determination. There are realtime versions of operating systems too, that allow one to determine the max-latencies, but it has its own cons. The best is to use an independent realtime unit. If you need more justification on why to use a realtime system, see this &lt;a href=&#34;https://www.youtube.com/watch?v=plCYsbmMbmY&#34;&gt;video by Linux foundation&lt;/a&gt; .&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;u-prus-u:f112cc63f5e4b6b33907400366d8b15d&#34;&gt;&lt;u&gt;&lt;strong&gt;PRUs&lt;/strong&gt;&lt;/u&gt;&lt;/h3&gt;

&lt;p&gt;The two PRUs enclosed in the PRU-ICSS subsystem are specially designed for high speed, low latency, realtime processing. PRUs are basically 32 bit RISC processors that can work independent of the MPU. As is shown in the figure below, there are many more peripherals that are enclosed in the PRU-ICSS unit. Integration of all these peripherals in the PRU-ICSS aims to make realtime processing easy, reliable and fast. After all that &lt;em&gt;&amp;ldquo;realtime&amp;rdquo;&lt;/em&gt; stuff above, you may ask, &amp;ldquo;How does the PRUs make realtime thing possible ? after all they are yet another processing core.&amp;rdquo; Well, No, they are not &lt;em&gt;&amp;ldquo;yet another&amp;rdquo;&lt;/em&gt; processing unit, but are special kind of processing unit. They have very limited yet enough number of instructions to program with and almost all of them get executed in single cycle (ie 5 nSec). Each instruction has a perfectly deterministic latency (provided its accessing PRU-ICSS resources, more on this later), has no caches or pipelines and is equipped with enhanced GPIO unit. Using PRUs, you can toggle a GPO at about 50MHz, and believe me, thats a great thing for a SoC having a general purpose OS on it.&lt;br /&gt;
This figure down here may look a bit complex, its rather simple and will be very useful once you understand it.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://zeekhuge.github.io/images/PRUSS.png&#34; alt=&#34;PRU-ICSS&#34; title=&#34;PRU-ICSS&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;[Note: This post is just to make you comfortable with PRUs for further experimenting and learning, so we are not going to go into deep details of various peripherals in PRU-ICSS. I am just going to give an overview of some of them. We will learn how to use various peripherals in later posts.]&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;So lets go ahead and understand some of the most used peripherals inside PRU-ICSS with reference to the above figure:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;u&gt;&lt;strong&gt;PRU0 and PRU1 cores&lt;/u&gt; :&lt;/strong&gt;
These are the 2 PRU ( Programmable Realtime Unit ) cores we have been talking about. They are 32-bit processors based on RISC design strategy. As a result, they need just a handful of assembly instructions to program them, and most of them, as already stated earlier, execute in one single cycle. The two PRUs are identical in every aspect. Each one them has 8K bytes of program RAM aka instruction RAM or iRAM for short. Apart from the iRam, they have 30, 32-bit general purpose registers in each of them.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;u&gt;&lt;strong&gt;Enhanced GPIO&lt;/u&gt; :&lt;/strong&gt;
You can see a block named &lt;em&gt;Enhanced GPIO&lt;/em&gt; directly connected to each of those PRU cores in the figure. The word &amp;ldquo;&lt;em&gt;Enhanced&lt;/em&gt;&amp;rdquo; is used because of some nifty modes that they have. They are:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Direct Mode : In this mode, all the GPIOs are directly connected to the PRUs internal register. That basically means that whenever the PRU reads the register associated with the GPI, it gets the instantaneous value of the GPI. Same is the case with output, whatever is written to output associated register, appears directly on the GPOs.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Parallel Capture mode (input only): In this mode, one of the GPI is used as an external strobe and other GPIs to capture data. That basically means, the data will be automatically captured by the GPI module when, for example, there is a positive rising edge on its external strobe pin.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;28-bit Shift (input only) : Each PRU has got a shift register that can be used in this mode of operation, to get serial data as input from one of its input pins. The sampling rate can be varied using clock divisors inside the PRUs.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Shift out (output only): This mode is kind of opposite to the 28-bit shift mode, such that, in this mode, the shift register is used to output serial data through one of its GPO.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;u&gt;&lt;strong&gt;OCP ports&lt;/u&gt; :&lt;/strong&gt;
The OCP ports (Open Core Protocol ports) are generally used for communication between various subsystem on the same chip. So as you might have already guessed, these ports are used to communicate with other subsystems, external to the PRU-ICSS, that are present on the SoC. These ports allow &lt;em&gt;PRU&lt;/em&gt; to &lt;em&gt;SoC peripheral (RAM, SPI unit, ADC etc)&lt;/em&gt; communication, or &lt;em&gt;A8 MPU&lt;/em&gt; to &lt;em&gt;PRU-ICSS peripheral (shared RAM, INTC, instruction RAM etc)&lt;/em&gt; communication. The OCP master port is for PRU to external peripheral (via L3 connect bus) communication and OCP slave port is for External peripheral to PRU-ICSS peripheral communication (via L4 connect bus).&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;u&gt;&lt;strong&gt;INTC&lt;/u&gt; :&lt;/strong&gt;
This is an Interrupt controller to manage interrupts from one PRU to other, from PRU to external peripherals or from external peripherals to PRU. At this point you may ask that, &lt;em&gt;for example PRUs are doing some critical job and get interrupted, how does that make it deterministic and reliable for realtime systems ?&lt;/em&gt; Well, interrupts on PRU are not interrupts in classical sense. Occurrence of an interrupt does not actually interrupts the current execution, but it sets an known bit, which needs to be checked by the software on the PRU to perform related task. So for example, if the PRU is doing a critical job, it might detect the interrupt by checking that interrupt-related-bit and choose not to do anything for now, or it might not even check that bit while its doing those critical jobs. There is more to INTC, but thats for later.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;u&gt;&lt;strong&gt;Scratch Pad&lt;/u&gt; :&lt;/strong&gt;
One of the nifty features that PRUs have is the presence of scratch pad. Its a set of 3 banks, with 30, 32 bit registers in each. The most interesting thing about these scratch pads is their broadside interface, which allows swapping of all these 30 registers, between PRU0 and PRU1 or between PRU-n and Bank-m, in just one single cycle. Isn&amp;rsquo;t that cool !
The figure shows this arrangement of registers and scratch pad.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;https://zeekhuge.github.io/images/scratch_pad.png&#34; alt=&#34;Scratch Pad&#34; title=&#34;Scratch_pad&#34; /&gt;&lt;/p&gt;

&lt;p&gt;In addition to all this, PRU-ICSS unit also has MAC (Multiplier - Accumulator unit) for each of the PRUs, a CFG unit that contains various configuration registers and a few more peripherals. We will further see how to use PRUs and various in-PRU-ICSS peripherals to make a realtime system in posts ahead.&lt;/p&gt;

&lt;p&gt;So thats all for this post. Next to it is this post explaining &lt;a href=&#34;https://zeekhuge.github.io/post/working_with_prus_beagleboneblack_remoteproc/&#34;&gt;&lt;em&gt;remoteproc&lt;/em&gt;&lt;/a&gt;, Linux way of working with PRU.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>